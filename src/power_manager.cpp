#include "power_manager.h"
#include "logger.h"
#include "debug_logger.h"

#ifndef MOCK_MODE
#include <esp_sleep.h>
#include <esp_pm.h>
#include <driver/adc.h>
#include <driver/gpio.h>
// ULP RISC-V support requires esp_ulp_riscv.h + libulp.a from ESP-IDF's ulp component.
// framework-arduinoespressif32 does not bundle these for ESP32-C3 as of v3.0.0.
// Define HAS_ULP_RISCV=1 in build_flags when the framework adds them; until then mode 2
// falls back to standard GPIO deep-sleep wakeup (same behaviour as mode 1's deep sleep).
#ifdef HAS_ULP_RISCV
#include <esp_ulp_riscv.h>

// Linker symbols generated by PlatformIO ULP build from ulp/ulp_pir_monitor.c
extern const uint32_t ulp_pir_monitor_start[];
extern const uint32_t ulp_pir_monitor_size;   // size in BYTES
#endif

// ESP32-C3 specific includes for deep sleep GPIO wakeup
#if CONFIG_IDF_TARGET_ESP32C3
#include <esp_chip_info.h>
#include "hal/adc_ll.h"  // Low-level SAR ADC — bypasses libdriver.a for ADC2 on C3
#endif
#endif

// Global power manager instance
PowerManager g_power;

// RTC memory structure for state persistence
#ifndef MOCK_MODE
RTC_DATA_ATTR struct {
    uint32_t magic;
    PowerManager::PowerState lastState;
    uint32_t wakeCount;
    uint32_t deepSleepCount;
    float lastBatteryVoltage;
    time_t sleepEntryRTC;
} rtcMemory;
#else
static struct {
    uint32_t magic;
    PowerManager::PowerState lastState;
    uint32_t wakeCount;
    uint32_t deepSleepCount;
    float lastBatteryVoltage;
    time_t sleepEntryRTC;
} rtcMemory;
#endif

#define RTC_MAGIC 0xBADC0FFE

PowerManager::PowerManager()
    : m_state(STATE_ACTIVE)
    , m_initialized(false)
    , m_batteryMonitoringEnabled(false)
    , m_powerSavingMode(0)
    , m_enablePowerSavingOnUSB(false)
    , m_lastActivity(0)
    , m_lastBatteryUpdate(0)
    , m_stateEnterTime(0)
    , m_startTime(0)
    , m_voltageSampleIndex(0)
    , m_voltageSamplesFilled(false)
    , m_onLowBattery(nullptr)
    , m_onCriticalBattery(nullptr)
    , m_onUsbPower(nullptr)
    , m_onWake(nullptr)
{
    // Initialize default configuration
    m_config.idleToLightSleepMs = 180000;       // 3 minutes (user configurable: 1-10 min)
    m_config.lightSleepToDeepSleepMs = 60000;   // 1 minute from light sleep (0 = skip light sleep)
    m_config.lowBatteryThreshold = 3.4f;        // 3.4V (~20%)
    m_config.criticalBatteryThreshold = 3.2f;   // 3.2V (~5%)
    m_config.batteryCheckInterval = 10000;      // 10 seconds
    m_config.enableAutoSleep = false;
    m_config.enableDeepSleep = false;
    m_config.voltageCalibrationOffset = 0.0f;
    m_config.lowBatteryLEDBrightness = 128;     // 50% brightness when low battery

    // Initialize battery status
    m_batteryStatus.voltage = 0.0f;
    m_batteryStatus.percentage = 0;
    m_batteryStatus.usbPower = false;
    m_batteryStatus.low = false;
    m_batteryStatus.critical = false;

    // Initialize stats
    m_stats.uptime = 0;
    m_stats.activeTime = 0;
    m_stats.sleepTime = 0;
    m_stats.wakeCount = 0;
    m_stats.deepSleepCount = 0;
    m_stats.avgCurrent = 0.0f;

    // Initialize voltage samples
    for (int i = 0; i < VOLTAGE_SAMPLES; i++) {
        m_voltageSamples[i] = 0.0f;
    }
}

PowerManager::~PowerManager() {
}

void PowerManager::setBatteryMonitoringEnabled(bool enabled) {
    m_batteryMonitoringEnabled = enabled;
}

void PowerManager::setPowerSavingMode(uint8_t mode) {
    if (mode > 2) mode = 0;
    if (mode == m_powerSavingMode) return;  // No change — avoid redundant writes and log spam

    // Defensive: log the old state before modifying it
    DEBUG_LOG_SYSTEM("Power: setPowerSavingMode(%u) called (current mode=%u, autoSleep=%s, deepSleep=%s)",
        mode, m_powerSavingMode,
        m_config.enableAutoSleep ? "true" : "false",
        m_config.enableDeepSleep ? "true" : "false");

    m_powerSavingMode = mode;
    m_config.enableAutoSleep = (mode >= 1);
    m_config.enableDeepSleep = (mode == 2);
    DEBUG_LOG_SYSTEM("Power: mode set to %u (autoSleep=%s, deepSleep=%s)",
        mode,
        m_config.enableAutoSleep ? "true" : "false",
        m_config.enableDeepSleep ? "true" : "false");
}

void PowerManager::setEnablePowerSavingOnUSB(bool enable) {
    if (m_enablePowerSavingOnUSB != enable) {
        DEBUG_LOG_SYSTEM("USB power override: %s -> %s",
                         m_enablePowerSavingOnUSB ? "ON" : "OFF",
                         enable ? "ON" : "OFF");
        m_enablePowerSavingOnUSB = enable;

        // Immediately re-evaluate power state
        if (!enable && m_batteryStatus.usbPower && m_state != STATE_USB_POWER) {
            // Override disabled + USB connected -> force USB_POWER state
            setState(STATE_USB_POWER, "USB override disabled");
        } else if (enable && m_state == STATE_USB_POWER && m_batteryStatus.usbPower) {
            // Override enabled + in USB_POWER state -> return to ACTIVE
            DEBUG_LOG_SYSTEM("USB override enabled - allowing power saving on USB power");
            setState(STATE_ACTIVE, "USB override enabled");
        }
    }
}

bool PowerManager::begin(const Config* config) {
    if (m_initialized) {
        DEBUG_LOG_SYSTEM("Power: Already initialized");
        return true;
    }

    // Apply custom configuration if provided
    if (config) {
        m_config = *config;
    }

    DEBUG_LOG_SYSTEM("Power: Initializing");

#ifndef MOCK_MODE
    // Configure ADC for battery voltage reading
    // Note: ESP32-C3 uses different ADC API - analogRead() works via Arduino framework
    // The adc1_config functions are deprecated in newer ESP-IDF
    #if !CONFIG_IDF_TARGET_ESP32C3
    adc1_config_width(ADC_WIDTH_BIT_12);
    adc1_config_channel_atten(BATTERY_ADC_CHANNEL, ADC_ATTEN_DB_12);
    #else
    // ESP32-C3: battery is on ADC2_CH0 (GPIO5), read via adc_ll_* HAL functions
    // which bypass the ADC driver entirely.  Three things the driver normally
    // does must be replicated here:
    //   1. Configure the GPIO as an analog input (no pulls).
    //   2. Enable the SAR ADC peripheral clock (APB source, un-gate it).
    //   3. Set power management to FSM mode so the hardware powers the SAR
    //      on/off automatically for each oneshot conversion.
    // Without (2) and (3) the onetime_start bit is written but the peripheral
    // never clocks, so the conversion never completes and raw reads as garbage.
    // Always initialise the ADC hardware; actual reads are gated at runtime by
    // m_batteryMonitoringEnabled (set via setBatteryMonitoringEnabled()).
    gpio_set_direction((gpio_num_t)PIN_BATTERY_ADC, GPIO_MODE_INPUT);
    gpio_pullup_dis((gpio_num_t)PIN_BATTERY_ADC);
    gpio_pulldown_dis((gpio_num_t)PIN_BATTERY_ADC);
    adc_ll_digi_controller_clk_div(ADC_LL_CLKM_DIV_NUM_DEFAULT,   // Set clock divider
                                   ADC_LL_CLKM_DIV_B_DEFAULT,   // before enabling clock —
                                   ADC_LL_CLKM_DIV_A_DEFAULT);  // div=0 means no output.
    adc_ll_digi_clk_sel(false);                     // APB clock source + sar_clk_gated = 1
    APB_SARADC.apb_adc_clkm_conf.clk_en = 1;       // Actually enable the clock module output.
                                                     // clk_sel + sar_clk_gated alone are not
                                                     // sufficient; this bit (default 0) gates
                                                     // the divided clock into the SAR peripheral.
    adc_ll_digi_set_power_manage(ADC_POWER_BY_FSM); // FSM drives XPD for oneshot polling

    // VBUS detection (GPIO6): pull down so it reads LOW when USB is disconnected.
    // Without this the pin floats HIGH on battery-only and isUsbPower() returns true.
    // Always active — USB detection is useful regardless of battery monitoring.
    gpio_set_direction((gpio_num_t)PIN_VBUS_DETECT, GPIO_MODE_INPUT);
    gpio_pulldown_en((gpio_num_t)PIN_VBUS_DETECT);
    #endif
#endif

    m_startTime = millis();
    m_lastActivity = millis();
    m_lastBatteryUpdate = 0; // Force immediate update

    // Try to restore state from RTC memory
    if (restoreStateFromRTC()) {
        // Deep sleep reboots the CPU — wakeCount was already incremented by
        // restoreStateFromRTC(), so go straight to source detection without
        // calling wakeUp() (which would double-increment).
        m_state = STATE_DEEP_SLEEP;   // Correct previous state for wake log
        uint32_t deepSleepDurationMs = 0;
#ifndef MOCK_MODE
        deepSleepDurationMs = (uint32_t)(rtc_time_get() - rtcMemory.sleepEntryRTC) * 1000;
#endif
        detectAndRouteWakeSource(deepSleepDurationMs);
    } else {
        DEBUG_LOG_SYSTEM("Power: Fresh boot, initializing RTC memory");
        rtcMemory.magic = RTC_MAGIC;
        rtcMemory.wakeCount = 0;
        rtcMemory.deepSleepCount = 0;
    }

    m_initialized = true;

    // Initial battery check
    updateBatteryStatus();

    DEBUG_LOG_SYSTEM("Power: Initialized (battery: %.2fV, %u%%)",
             m_batteryStatus.voltage, m_batteryStatus.percentage);

    // Critical battery boot protection
    // If battery is critical and not charging, show warning and shutdown.
    // Sanity guard: a LiPo powering the MCU can never actually read below
    // ~2.5 V.  Anything below 2.0 V is an ADC read failure — do NOT shut
    // down in that case or the device becomes unrecoverable without a full
    // erase.
    if (m_batteryStatus.voltage < 2.0f) {
        DEBUG_LOG_SYSTEM("Power: WARNING - battery voltage %.2fV is suspiciously low (likely ADC failure). Skipping shutdown protection.", m_batteryStatus.voltage);
    } else if (millis() - m_startTime < POWER_BOOT_GRACE_PERIOD_MS) {
        DEBUG_LOG_SYSTEM("Power: Boot grace period active (%ums) - deferring critical battery check", POWER_BOOT_GRACE_PERIOD_MS);
    } else if (m_batteryStatus.critical && !m_batteryStatus.usbPower) {
        DEBUG_LOG_SYSTEM("Power: Critical battery detected on boot (%.2fV), shutting down", m_batteryStatus.voltage);

        #ifndef MOCK_MODE
        // Flash LED 3 times as shutdown warning
        pinMode(PIN_HAZARD_LED, OUTPUT);
        for (int i = 0; i < 3; i++) {
            // Use raw GPIO to avoid dependency on LED HAL
            digitalWrite(PIN_HAZARD_LED, HIGH);
            delay(200);
            digitalWrite(PIN_HAZARD_LED, LOW);
            delay(200);
        }
        #endif

        // Enter deep sleep immediately (device will not wake until charged)
        enterDeepSleep(0, "critical battery boot");
        // Never returns
    }

    return true;
}

void PowerManager::update() {
    if (!m_initialized) {
        return;
    }

    // Update battery status periodically
    if (millis() - m_lastBatteryUpdate >= m_config.batteryCheckInterval) {
        updateBatteryStatus();
        m_lastBatteryUpdate = millis();
    }

    // Handle power state
    handlePowerState();

    // Update statistics
    updateStats();

    // Log periodic state summary
    logStateSummary();
}

void PowerManager::updateBatteryStatus() {
    // Read voltage
    float voltage = getBatteryVoltage();
    m_batteryStatus.voltage = voltage;

    // Calculate percentage
    m_batteryStatus.percentage = calculateBatteryPercentage(voltage);

    // Check USB power state
    bool wasUsbPower = m_batteryStatus.usbPower;
    m_batteryStatus.usbPower = isUsbPower();

    // Detect USB power connection
    if (m_batteryStatus.usbPower && !wasUsbPower) {
        DEBUG_LOG_SYSTEM("Power: USB power connected");
        if (m_onUsbPower) {
            m_onUsbPower();
        }
    }

    // Check battery thresholds
    bool wasLow = m_batteryStatus.low;
    bool wasCritical = m_batteryStatus.critical;

    m_batteryStatus.low = (voltage < m_config.lowBatteryThreshold);
    m_batteryStatus.critical = (voltage < m_config.criticalBatteryThreshold);

    // Trigger callbacks on state changes
    if (m_batteryStatus.critical && !wasCritical) {
        DEBUG_LOG_SYSTEM("Power: Critical battery! (%.2fV)", voltage);
        if (m_onCriticalBattery) {
            m_onCriticalBattery();
        }
    } else if (m_batteryStatus.low && !wasLow) {
        DEBUG_LOG_SYSTEM("Power: Low battery (%.2fV)", voltage);
        if (m_onLowBattery) {
            m_onLowBattery();
        }
    }
}

float PowerManager::getBatteryVoltage() {
    float rawVoltage = readBatteryVoltageRaw();
    addVoltageSample(rawVoltage);
    return getFilteredVoltage();
}

float PowerManager::readBatteryVoltageRaw() {
#ifndef MOCK_MODE
    if (!m_batteryMonitoringEnabled) {
        // Battery monitoring is disabled at runtime.  Return nominal voltage
        // so the system does not trigger low/critical battery state transitions.
        // Enable via the web UI config tab (requires external voltage divider
        // on GPIO5 — see docs/hardware/HARDWARE_ASSEMBLY.md).
        return 3.8f;
    }
    // ESP32-C3: GPIO5 is ADC2_CH0. The ADC driver in libdriver.a is
    // pre-compiled and unconditionally rejects ADC2 on C3 — the
    // CONFIG_ADC_ONESHOT_FORCE_USE_ADC2_ON_C3 build flag cannot reach it.
    // Use adc_ll inline HAL functions to read the SAR ADC registers directly,
    // bypassing the driver validation entirely.
#if CONFIG_IDF_TARGET_ESP32C3
    adc_ll_onetime_set_channel(ADC_NUM_2, ADC_CHANNEL_0);  // ADC2, channel 0 = GPIO5
    adc_ll_onetime_set_atten(ADC_ATTEN_DB_12);     // 12dB attenuation: 0-3.3V
    adc_ll_onetime_sample_enable(ADC_NUM_2, true);
    adc_ll_onetime_start(true);

    // Poll for conversion complete (typically sub-microsecond)
    uint32_t timeout = 1000;
    while (APB_SARADC.onetime_sample.onetime_start && --timeout) {}

    uint16_t raw = adc_ll_adc2_read();
#else
    uint16_t raw = analogRead(PIN_BATTERY_ADC);
#endif

    // Convert to voltage (12-bit ADC, 0-3.3V range)
    // With voltage divider (2:1 ratio), multiply by 2
    float voltage = (raw / 4095.0f) * 3.3f * 2.0f;

    // Apply calibration offset
    voltage += m_config.voltageCalibrationOffset;

    // VERBOSE ADC log, throttled: only on significant change or every 100 s
    {
        static float lastLoggedVoltage = -1.0f;
        static uint32_t lastVoltageLogTime = 0;
        uint32_t now = millis();
        if (lastLoggedVoltage < 0.0f ||
            fabsf(voltage - lastLoggedVoltage) >= 0.05f ||
            (now - lastVoltageLogTime) >= 100000) {
            g_debugLogger.log(DebugLogger::LEVEL_VERBOSE, DebugLogger::CAT_SYSTEM,
                "Power: ADC2 raw=%u voltage=%.3fV", raw, voltage);
            lastLoggedVoltage = voltage;
            lastVoltageLogTime = now;
        }
    }

    return voltage;
#else
    // Mock mode: return simulated voltage
    return 3.8f; // Nominal battery voltage
#endif
}

uint8_t PowerManager::getBatteryPercentage() {
    return m_batteryStatus.percentage;
}

uint8_t PowerManager::calculateBatteryPercentage(float voltage) {
    // LiPo discharge curve (simplified piecewise linear)
    // 4.2V = 100%
    // 3.7V = 50%
    // 3.0V = 0%

    // Clamp voltage range
    if (voltage >= 4.2f) return 100;
    if (voltage <= 3.0f) return 0;

    // Piecewise linear approximation
    if (voltage >= 3.7f) {
        // 3.7V-4.2V = 50%-100% (0.5V range = 50% capacity)
        return 50 + (uint8_t)(((voltage - 3.7f) / 0.5f) * 50.0f);
    } else {
        // 3.0V-3.7V = 0%-50% (0.7V range = 50% capacity)
        return (uint8_t)(((voltage - 3.0f) / 0.7f) * 50.0f);
    }
}

void PowerManager::addVoltageSample(float voltage) {
    m_voltageSamples[m_voltageSampleIndex] = voltage;
    m_voltageSampleIndex = (m_voltageSampleIndex + 1) % VOLTAGE_SAMPLES;
    if (m_voltageSampleIndex == 0) {
        m_voltageSamplesFilled = true;
    }
}

float PowerManager::getFilteredVoltage() {
    float sum = 0.0f;
    int count = m_voltageSamplesFilled ? VOLTAGE_SAMPLES : m_voltageSampleIndex;

    if (count == 0) return 0.0f;

    for (int i = 0; i < count; i++) {
        sum += m_voltageSamples[i];
    }

    return sum / count;
}

bool PowerManager::isUsbPower() {
#ifndef MOCK_MODE
    // Check VBUS detection pin
    return digitalRead(VBUS_DETECT_PIN) == HIGH;
#else
    // Mock mode: no USB power
    return false;
#endif
}

void PowerManager::handlePowerState() {
    switch (m_state) {
        case STATE_ACTIVE:
        case STATE_MOTION_ALERT:
            // Boot grace period: suppress battery transitions and auto-sleep
            // until ADC has settled and USB power has been reliably detected.
            // USB power detection is still allowed during the grace period.
            if (millis() - m_startTime < POWER_BOOT_GRACE_PERIOD_MS) {
                // Log grace period status every 10 seconds
                static uint32_t lastGraceLog = 0;
                if (millis() - lastGraceLog >= 10000) {
                    uint32_t remaining = POWER_BOOT_GRACE_PERIOD_MS - (millis() - m_startTime);
                    DEBUG_LOG_SYSTEM("Boot grace period: %lums remaining - sleep blocked", remaining);
                    lastGraceLog = millis();
                }
                if (m_batteryStatus.usbPower) {
                    setState(STATE_USB_POWER);
                }
                break;
            }
            // Check for battery issues
            if (m_batteryStatus.critical && !m_batteryStatus.usbPower) {
                DEBUG_LOG_SYSTEM("Critical battery: %.2fV (%.0f%%) - entering CRITICAL_BATTERY state",
                                 m_batteryStatus.voltage, m_batteryStatus.percentage);
                setState(STATE_CRITICAL_BATTERY);
            } else if (m_batteryStatus.low && !m_batteryStatus.usbPower) {
                DEBUG_LOG_SYSTEM("Low battery: %.2fV (%.0f%%) - entering LOW_BATTERY state",
                                 m_batteryStatus.voltage, m_batteryStatus.percentage);
                setState(STATE_LOW_BATTERY);
            } else if (m_batteryStatus.usbPower && !m_enablePowerSavingOnUSB) {
                DEBUG_LOG_SYSTEM("USB power detected - transitioning to USB_POWER state (sleep disabled)");
                setState(STATE_USB_POWER);
            } else if (m_config.enableAutoSleep && shouldEnterSleep()) {
                char reason[64];
                snprintf(reason, sizeof(reason), "idle timeout %ums", millis() - m_lastActivity);
                if (m_config.enableDeepSleep && m_config.lightSleepToDeepSleepMs == 0) {
                    enterDeepSleep(0, reason);
                } else {
                    enterLightSleep(0, reason);
                }
            }
            break;

        case STATE_LIGHT_SLEEP:
            // Check if should transition to deep sleep
            if (m_config.enableDeepSleep && m_config.lightSleepToDeepSleepMs > 0) {
                uint32_t timeInLightSleep = millis() - m_stateEnterTime;
                if (timeInLightSleep >= m_config.lightSleepToDeepSleepMs) {
                    char reason[64];
                    snprintf(reason, sizeof(reason), "light sleep timeout %ums", timeInLightSleep);
                    enterDeepSleep(0, reason);
                }
            }
            break;

        case STATE_DEEP_SLEEP:
            // Handled by deep sleep wake-up (system reboots)
            break;

        case STATE_LOW_BATTERY:
            // Check if battery recovered
            if (m_batteryStatus.usbPower) {
                setState(STATE_USB_POWER);
            } else if (!m_batteryStatus.low) {
                setState(STATE_ACTIVE);
            } else if (m_batteryStatus.critical) {
                setState(STATE_CRITICAL_BATTERY);
            }
            break;

        case STATE_CRITICAL_BATTERY:
            // Only exit if USB power connected
            if (m_batteryStatus.usbPower) {
                setState(STATE_USB_POWER);
            } else {
                enterDeepSleep(0, "critical battery"); // Indefinite sleep until charged
            }
            break;

        case STATE_USB_POWER:
            // Log periodic reminder that sleep is disabled on USB
            {
                static uint32_t lastUSBLog = 0;
                if (millis() - lastUSBLog >= 300000) {  // Every 5 minutes
                    DEBUG_LOG_SYSTEM("USB_POWER state: sleep disabled while on USB power (battery: %.2fV)",
                                     m_batteryStatus.voltage);
                    lastUSBLog = millis();
                }
            }
            // Return to active when unplugged
            if (!m_batteryStatus.usbPower) {
                if (m_batteryStatus.critical) {
                    setState(STATE_CRITICAL_BATTERY);
                } else if (m_batteryStatus.low) {
                    setState(STATE_LOW_BATTERY);
                } else {
                    setState(STATE_ACTIVE);
                }
            }
            break;
    }
}

void PowerManager::logStateSummary() {
    static uint32_t lastSummaryLog = 0;

    // Log every 5 minutes
    if (millis() - lastSummaryLog < 300000) {
        return;
    }
    lastSummaryLog = millis();

    uint32_t idleTime = millis() - m_lastActivity;
    uint32_t timeInState = millis() - m_stateEnterTime;

    // Pre-compute all complex expressions to avoid stack corruption in variadic functions
    uint32_t stateMinutes = timeInState / 60000;
    uint32_t stateSeconds = (timeInState % 60000) / 1000;
    const char* batterySource = m_batteryStatus.usbPower ? "[USB]" : "[BATTERY]";
    const char* autoSleepStr = m_config.enableAutoSleep ? "ON" : "OFF";
    const char* deepSleepStr = m_config.enableDeepSleep ? "ON" : "OFF";
    const char* usbOverrideStr = m_enablePowerSavingOnUSB
        ? "ENABLED (power saving on USB)"
        : "DISABLED (default)";
    uint32_t idleSeconds = idleTime / 1000;
    uint32_t idleDecimals = (idleTime % 1000) / 100;
    uint32_t thresholdSeconds = m_config.idleToLightSleepMs / 1000;
    uint32_t thresholdDecimals = (m_config.idleToLightSleepMs % 1000) / 100;

    DEBUG_LOG_SYSTEM("=== Power State Summary ===");
    DEBUG_LOG_SYSTEM("State: %s (for %lu.%lum)",
                     getStateName(m_state), stateMinutes, stateSeconds);
    DEBUG_LOG_SYSTEM("Battery: %.2fV (%.0f%%) %s",
                     m_batteryStatus.voltage,
                     m_batteryStatus.percentage,
                     batterySource);
    DEBUG_LOG_SYSTEM("Power Mode: %d (autoSleep=%s, deepSleep=%s)",
                     m_powerSavingMode, autoSleepStr, deepSleepStr);
    DEBUG_LOG_SYSTEM("USB Override: %s", usbOverrideStr);
    DEBUG_LOG_SYSTEM("Idle: %lu.%lus / %lu.%lus",
                     idleSeconds, idleDecimals, thresholdSeconds, thresholdDecimals);

    // Explain why sleep is blocked (if applicable)
    if (m_state == STATE_USB_POWER) {
        DEBUG_LOG_SYSTEM("Sleep: BLOCKED (USB power connected)");
    } else if (m_state == STATE_CRITICAL_BATTERY || m_state == STATE_LOW_BATTERY) {
        DEBUG_LOG_SYSTEM("Sleep: BLOCKED (battery state)");
    } else if (!m_config.enableAutoSleep) {
        DEBUG_LOG_SYSTEM("Sleep: BLOCKED (autoSleep disabled, mode=%d)", m_powerSavingMode);
    } else if (idleTime < m_config.idleToLightSleepMs) {
        uint32_t remaining = m_config.idleToLightSleepMs - idleTime;
        uint32_t remainingSeconds = remaining / 1000;
        uint32_t remainingDecimals = (remaining % 1000) / 100;
        DEBUG_LOG_SYSTEM("Sleep: WAITING (need %lu.%lus more idle time)",
                         remainingSeconds, remainingDecimals);
    } else {
        DEBUG_LOG_SYSTEM("Sleep: READY (conditions met)");
    }

    DEBUG_LOG_SYSTEM("==========================");
}

void PowerManager::setState(PowerState newState, const char* reason) {
    if (m_state != newState) {
        if (reason) {
            DEBUG_LOG_SYSTEM("Power: %s -> %s (%s)",
                getStateName(m_state), getStateName(newState), reason);
        } else {
            DEBUG_LOG_SYSTEM("Power: %s -> %s",
                getStateName(m_state), getStateName(newState));
        }
        m_state = newState;
        m_stateEnterTime = millis();
    }
}

bool PowerManager::shouldEnterSleep() {
    uint32_t idleTime = millis() - m_lastActivity;

    if (!m_config.enableAutoSleep) {
        // Log only every 60 seconds to avoid spam
        static uint32_t lastAutoSleepLog = 0;
        if (millis() - lastAutoSleepLog >= 60000) {
            DEBUG_LOG_SYSTEM("Sleep check: autoSleep=DISABLED - sleep not allowed");
            lastAutoSleepLog = millis();
        }
        return false;
    }

    if (idleTime >= m_config.idleToLightSleepMs) {
        DEBUG_LOG_SYSTEM("Sleep check: READY - idle=%lums >= timeout=%lums",
                         idleTime, m_config.idleToLightSleepMs);
        return true;
    }

    // Log only every 60 seconds to avoid spam
    static uint32_t lastIdleLog = 0;
    if (millis() - lastIdleLog >= 60000) {
        uint32_t remaining = m_config.idleToLightSleepMs - idleTime;
        DEBUG_LOG_SYSTEM("Sleep check: NOT READY - idle=%lums < timeout=%lums (need %lu.%lus more)",
                         idleTime, m_config.idleToLightSleepMs,
                         remaining / 1000, (remaining % 1000) / 100);
        lastIdleLog = millis();
    }

    return false;
}

void PowerManager::enterLightSleep(uint32_t duration_ms, const char* reason) {
    DEBUG_LOG_SYSTEM("Entering light sleep: duration=%lums, wakeup=[GPIO,TIMER]", duration_ms);

    saveStateToRTC();
    setState(STATE_LIGHT_SLEEP, reason);

#ifndef MOCK_MODE
    // Configure wake sources
    if (duration_ms > 0) {
        esp_sleep_enable_timer_wakeup(duration_ms * 1000ULL); // Convert to µs
        DEBUG_LOG_SYSTEM("Light sleep: timer wakeup enabled (%lums)", duration_ms);
    }

    // ESP32-C3 uses GPIO wakeup for light sleep (gpio_wakeup_enable)
    // Enable GPIO wakeup source first
    esp_sleep_enable_gpio_wakeup();

    // Wake on PIR motion (HIGH level)
    gpio_wakeup_enable((gpio_num_t)PIR_SENSOR_PIN, GPIO_INTR_HIGH_LEVEL);

    // Wake on button press (LOW level since button is active-low with pull-up)
    gpio_wakeup_enable((gpio_num_t)BUTTON_PIN, GPIO_INTR_LOW_LEVEL);

    DEBUG_LOG_SYSTEM("Light sleep: GPIO wakeup enabled (PIR pin=%d, BUTTON pin=%d)",
                     PIR_SENSOR_PIN, BUTTON_PIN);

    // Reduce CPU frequency (ESP32-C3 max is 160MHz)
    DEBUG_LOG_SYSTEM("Light sleep: reducing CPU 160MHz -> 80MHz");
    setCPUFrequency(80);

    // Enter light sleep
    DEBUG_LOG_SYSTEM("Light sleep: entering now...");
    esp_light_sleep_start();

    // Restore after wake (ESP32-C3 max is 160MHz, not 240MHz)
    setCPUFrequency(160);
    DEBUG_LOG_SYSTEM("Light sleep: woke up, CPU restored to 160MHz");
#endif

    // millis() on ESP32 is compensated for light sleep time
    uint32_t sleepDuration = millis() - m_stateEnterTime;
    wakeUp(sleepDuration);
}

void PowerManager::enterDeepSleep(uint32_t duration_ms, const char* reason) {
    saveStateToRTC();
    setState(STATE_DEEP_SLEEP, reason);

#ifndef MOCK_MODE
    // Configure wake sources
    if (duration_ms > 0) {
        esp_sleep_enable_timer_wakeup(duration_ms * 1000ULL);
    }

    // Button: always uses standard deep sleep GPIO wakeup (wakes on LOW — button pressed)
    gpio_set_direction((gpio_num_t)BUTTON_PIN, GPIO_MODE_INPUT);
    gpio_pullup_en((gpio_num_t)BUTTON_PIN);
    esp_deep_sleep_enable_gpio_wakeup(1ULL << BUTTON_PIN, ESP_GPIO_WAKEUP_GPIO_LOW);

    // PIR: mode 2 uses ULP coprocessor instead of GPIO wakeup for detection.
    // Modes 0/1 should not normally reach enterDeepSleep(), but configure GPIO
    // wakeup as a safety fallback if they do.
    if (m_powerSavingMode != 2) {
        gpio_set_direction((gpio_num_t)PIR_SENSOR_PIN, GPIO_MODE_INPUT);
        esp_deep_sleep_enable_gpio_wakeup(1ULL << PIR_SENSOR_PIN, ESP_GPIO_WAKEUP_GPIO_HIGH);
    }

    // Hold PIR power GPIO HIGH so sensors stay powered during deep sleep.
    // GPIO outputs tri-state without hold; if PIR loses VCC it cannot wake us.
    if (PIN_PIR_POWER != PIN_PIR_POWER_NONE) {
        digitalWrite(PIN_PIR_POWER, HIGH);
        gpio_hold_en((gpio_num_t)PIN_PIR_POWER);
    }

    // Mode 2: load and start ULP RISC-V program to monitor PIR GPIO
    if (m_powerSavingMode == 2) {
        startULPPirMonitor();
    }

    // Enter deep sleep (no return - system reboots on wake)
    esp_deep_sleep_start();
#endif
}

void PowerManager::wakeUp(uint32_t sleepDurationMs) {
    m_stats.wakeCount++;
    m_lastActivity = millis();

    detectAndRouteWakeSource(sleepDurationMs);

    if (m_onWake) {
        m_onWake();
    }
}

void PowerManager::detectAndRouteWakeSource(uint32_t sleepDurationMs) {
    const char* prevStateName = getStateName(m_state);
    const char* wakeSource = "Unknown";
    PowerState newState = STATE_ACTIVE;

    #ifndef MOCK_MODE
    esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();

    switch (wakeup_reason) {
        case ESP_SLEEP_WAKEUP_GPIO:
            // ESP32-C3 reports a single GPIO wake cause regardless of which pin
            // triggered it.  Distinguish by reading the button: if it is actively
            // LOW the user is holding it; otherwise the wake must have come from
            // the PIR sensor.
            if (gpio_get_level((gpio_num_t)BUTTON_PIN) == 0) {
                wakeSource = "Button";
                newState = STATE_ACTIVE;
            } else {
                wakeSource = "PIR motion";
                newState = STATE_MOTION_ALERT;
            }
            break;

        case ESP_SLEEP_WAKEUP_TIMER:
            wakeSource = "Timer";
            newState = STATE_ACTIVE;
            break;

        case ESP_SLEEP_WAKEUP_UNDEFINED:
            wakeSource = "Normal boot";
            newState = STATE_ACTIVE;
            break;

        case ESP_SLEEP_WAKEUP_ULP:
            // ULP woke us — this is always PIR motion (ULP only runs in
            // mode 2 and only triggers on GPIO1 HIGH).
            wakeSource = "ULP PIR motion";
            newState = STATE_MOTION_ALERT;
            break;

        default:
            wakeSource = "Unknown";
            newState = STATE_ACTIVE;
            break;
    }
    #endif

    // Format sleep duration
    char durationBuf[32];
    if (sleepDurationMs >= 60000) {
        snprintf(durationBuf, sizeof(durationBuf), "%um %us",
            sleepDurationMs / 60000, (sleepDurationMs % 60000) / 1000);
    } else if (sleepDurationMs >= 1000) {
        snprintf(durationBuf, sizeof(durationBuf), "%us", sleepDurationMs / 1000);
    } else {
        snprintf(durationBuf, sizeof(durationBuf), "%ums", sleepDurationMs);
    }

    // Single combined wake log — set state directly to avoid a second log from setState
    m_state = newState;
    m_stateEnterTime = millis();
    DEBUG_LOG_SYSTEM("Power: %s -> %s (wake: %s, slept %s)",
        prevStateName, getStateName(newState), wakeSource, durationBuf);
}

void PowerManager::recordActivity(const char* source) {
    m_lastActivity = millis();
    if (source) {
        g_debugLogger.log(DebugLogger::LEVEL_VERBOSE, DebugLogger::CAT_SYSTEM,
                         "Activity recorded: %s (idle timer reset)", source);
    } else {
        g_debugLogger.log(DebugLogger::LEVEL_VERBOSE, DebugLogger::CAT_SYSTEM,
                         "Activity recorded (idle timer reset)");
    }
}

uint32_t PowerManager::getTimeSinceActivity() const {
    return millis() - m_lastActivity;
}

void PowerManager::setCPUFrequency(uint8_t mhz) {
#ifndef MOCK_MODE
    // ESP32-C3 max frequency is 160MHz (not 240MHz like original ESP32)
    #if CONFIG_IDF_TARGET_ESP32C3
    if (mhz > 160) {
        mhz = 160;
    }
    #endif

    setCpuFrequencyMhz(mhz);
    DEBUG_LOG_SYSTEM("Power: CPU frequency set to %uMHz", mhz);
#endif
}

void PowerManager::setLEDBrightness(uint8_t percentage) {
    // This will be called by LED HAL implementations
    // Just log for now
    DEBUG_LOG_SYSTEM("Power: LED brightness set to %u%%", percentage);
}

void PowerManager::saveStateToRTC() {
    rtcMemory.magic = RTC_MAGIC;
    rtcMemory.lastState = m_state;
    rtcMemory.lastBatteryVoltage = m_batteryStatus.voltage;
    rtcMemory.deepSleepCount++;
#ifndef MOCK_MODE
    rtcMemory.sleepEntryRTC = (time_t)rtc_time_get();
#else
    rtcMemory.sleepEntryRTC = 0;
#endif
}

bool PowerManager::restoreStateFromRTC() {
    if (rtcMemory.magic != RTC_MAGIC) {
        return false;
    }

    m_stats.wakeCount = rtcMemory.wakeCount + 1;
    m_stats.deepSleepCount = rtcMemory.deepSleepCount;
    rtcMemory.wakeCount = m_stats.wakeCount;

    return true;
}

void PowerManager::updateStats() {
    m_stats.uptime = (millis() - m_startTime) / 1000;

    // Track time in current state
    uint32_t timeInState = (millis() - m_stateEnterTime) / 1000;

    if (m_state == STATE_ACTIVE || m_state == STATE_USB_POWER) {
        m_stats.activeTime += timeInState;
    } else {
        m_stats.sleepTime += timeInState;
    }

    // Reset state enter time for next update
    m_stateEnterTime = millis();

    // Calculate average current (simplified)
    // This would need actual current measurement in real implementation
    switch (m_state) {
        case STATE_ACTIVE:
            m_stats.avgCurrent = 240.0f; // mA
            break;
        case STATE_LIGHT_SLEEP:
            m_stats.avgCurrent = 30.0f;
            break;
        case STATE_DEEP_SLEEP:
            m_stats.avgCurrent = 0.12f;
            break;
        case STATE_LOW_BATTERY:
            m_stats.avgCurrent = 150.0f; // Reduced features
            break;
        case STATE_USB_POWER:
            m_stats.avgCurrent = 240.0f; // Full features on USB power
            break;
        default:
            m_stats.avgCurrent = 0.0f;
            break;
    }
}

void PowerManager::resetStats() {
    m_stats.uptime = 0;
    m_stats.activeTime = 0;
    m_stats.sleepTime = 0;
    m_stats.wakeCount = 0;
    m_stats.deepSleepCount = 0;
    m_stats.avgCurrent = 0.0f;

    m_startTime = millis();
    DEBUG_LOG_SYSTEM("Power: Statistics reset");
}

void PowerManager::startULPPirMonitor() {
#ifndef MOCK_MODE
#ifdef HAS_ULP_RISCV
    // Configure GPIO1 (PIR) as a clean input for ULP access
    gpio_set_direction((gpio_num_t)PIR_SENSOR_PIN, GPIO_MODE_INPUT);
    gpio_pullup_dis((gpio_num_t)PIR_SENSOR_PIN);
    gpio_pulldown_dis((gpio_num_t)PIR_SENSOR_PIN);

    // Load ULP binary into RTC SLOW memory.
    // esp_ulp_load_program len parameter is in WORDS; the size linker symbol is in BYTES.
    esp_err_t err = esp_ulp_load_program(0, ulp_pir_monitor_start,
                                         ulp_pir_monitor_size / sizeof(uint32_t));
    if (err != ESP_OK) {
        DEBUG_LOG_SYSTEM("Power: ULP load failed: %s. Falling back to GPIO wakeup.",
                         esp_err_to_string(err));
        esp_deep_sleep_enable_gpio_wakeup(1ULL << PIR_SENSOR_PIN, ESP_GPIO_WAKEUP_GPIO_HIGH);
        return;
    }

    err = esp_ulp_start(0);
    if (err != ESP_OK) {
        DEBUG_LOG_SYSTEM("Power: ULP start failed: %s. Falling back to GPIO wakeup.",
                         esp_err_to_string(err));
        esp_deep_sleep_enable_gpio_wakeup(1ULL << PIR_SENSOR_PIN, ESP_GPIO_WAKEUP_GPIO_HIGH);
        return;
    }

    DEBUG_LOG_SYSTEM("Power: ULP PIR monitor started");
#else
    // ULP RISC-V not available in this build environment (framework-arduinoespressif32
    // does not bundle ulp headers/lib for ESP32-C3 yet).  Fall back to standard GPIO
    // deep-sleep wakeup.  Motion detection still works; wakeup cause will be GPIO
    // rather than ESP_SLEEP_WAKEUP_ULP.
    DEBUG_LOG_SYSTEM("Power: ULP not available (build env). Using GPIO wakeup for PIR.");
    gpio_set_direction((gpio_num_t)PIR_SENSOR_PIN, GPIO_MODE_INPUT);
    esp_deep_sleep_enable_gpio_wakeup(1ULL << PIR_SENSOR_PIN, ESP_GPIO_WAKEUP_GPIO_HIGH);
#endif
#endif
}

const char* PowerManager::getStateName(PowerState state) {
    switch (state) {
        case STATE_ACTIVE: return "ACTIVE";
        case STATE_MOTION_ALERT: return "MOTION_ALERT";
        case STATE_LIGHT_SLEEP: return "LIGHT_SLEEP";
        case STATE_DEEP_SLEEP: return "DEEP_SLEEP";
        case STATE_LOW_BATTERY: return "LOW_BATTERY";
        case STATE_CRITICAL_BATTERY: return "CRITICAL_BATTERY";
        case STATE_USB_POWER: return "USB_POWER";
        default: return "UNKNOWN";
    }
}
