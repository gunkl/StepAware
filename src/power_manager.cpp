#include "power_manager.h"
#include "logger.h"
#include "debug_logger.h"

#ifndef MOCK_MODE
#include <WiFi.h>          // WiFi.disconnect() — used in enterLightSleep()
#include <esp_sleep.h>
#include <esp_pm.h>
#include <esp_task_wdt.h>
#include <esp_timer.h>
#include <driver/adc.h>
#include "esp_adc_cal.h"
#include <driver/gpio.h>
#include <soc/io_mux_reg.h>   // IO_MUX_GPIO1_REG, MCU_SEL_S, MCU_SEL_V
#include <soc/gpio_reg.h>    // GPIO_PIN4_REG, GPIO_PIN_INT_TYPE_GET, GPIO_PIN_WAKEUP_ENABLE_GET
// ULP RISC-V support requires esp_ulp_riscv.h + libulp.a from ESP-IDF's ulp component.
// framework-arduinoespressif32 does not bundle these for ESP32-C3 as of v3.0.0.
// Define HAS_ULP_RISCV=1 in build_flags when the framework adds them; until then mode 2
// falls back to standard GPIO deep-sleep wakeup (same behaviour as mode 1's deep sleep).
#ifdef HAS_ULP_RISCV
#include <esp_ulp_riscv.h>

// Linker symbols generated by PlatformIO ULP build from ulp/ulp_pir_monitor.c
extern const uint32_t ulp_pir_monitor_start[];
extern const uint32_t ulp_pir_monitor_size;   // size in BYTES
#endif

// ESP32-C3 specific includes for deep sleep GPIO wakeup
#if CONFIG_IDF_TARGET_ESP32C3
#include <esp_chip_info.h>
#include "hal/adc_ll.h"  // Low-level SAR ADC — bypasses libdriver.a for ADC2 on C3
#endif
#endif

// Global power manager instance
PowerManager g_power;

// RTC memory structure for state persistence
#ifndef MOCK_MODE
RTC_DATA_ATTR struct {
    uint32_t magic;
    PowerManager::PowerState lastState;
    uint32_t wakeCount;
    uint32_t deepSleepCount;
    float lastBatteryVoltage;
    time_t sleepEntryRTC;
    uint32_t deepSleepAccumulatedSec;
} rtcMemory;
#else
static struct {
    uint32_t magic;
    PowerManager::PowerState lastState;
    uint32_t wakeCount;
    uint32_t deepSleepCount;
    float lastBatteryVoltage;
    time_t sleepEntryRTC;
    uint32_t deepSleepAccumulatedSec;
} rtcMemory;
#endif

#define RTC_MAGIC 0xBADC0FF1

PowerManager::PowerManager()
    : m_state(STATE_ACTIVE)
    , m_initialized(false)
    , m_batteryMonitoringEnabled(false)
    , m_powerSavingMode(0)
    , m_enablePowerSavingOnUSB(false)
    , m_lastActivity(0)
    , m_lastBatteryUpdate(0)
    , m_stateEnterTime(0)
    , m_lastStatsUpdate(0)
    , m_startTime(0)
    , m_postWakeFlushUntil(0)
    , m_voltageSampleIndex(0)
    , m_voltageSamplesFilled(false)
    , m_adcCalValid(false)
    , m_adcCalMethod("none")
    , m_onLowBattery(nullptr)
    , m_onCriticalBattery(nullptr)
    , m_onUsbPower(nullptr)
    , m_onWake(nullptr)
    , m_motionWakePinCount(0)
{
    // Initialize default configuration
    m_config.idleToLightSleepMs = 180000;       // 3 minutes
    m_config.lightSleepToDeepSleepMs = 60000;   // 1 minute from light sleep (0 = skip light sleep)
    m_config.lowBatteryThreshold = 3.4f;        // 3.4V (~20%)
    m_config.criticalBatteryThreshold = 3.2f;   // 3.2V (~5%)
    m_config.batteryCheckInterval = 10000;      // 10 seconds
    m_config.enableAutoSleep = false;
    m_config.enableDeepSleep = false;
    m_config.voltageCalibrationOffset = 0.0f;
    m_config.lowBatteryLEDBrightness = 128;     // 50% brightness when low battery

    // Initialize battery status
    m_batteryStatus.voltage = 0.0f;
    m_batteryStatus.percentage = 0;
    m_batteryStatus.usbPower = false;
    m_batteryStatus.low = false;
    m_batteryStatus.critical = false;

    // Initialize stats
    m_stats.uptime = 0;
    m_stats.activeTime = 0;
    m_stats.sleepTime = 0;
    m_stats.wakeCount = 0;
    m_stats.deepSleepCount = 0;
    m_stats.avgCurrent = 0.0f;

    // Initialize voltage samples
    for (int i = 0; i < VOLTAGE_SAMPLES; i++) {
        m_voltageSamples[i] = 0.0f;
    }

    memset(m_motionWakePins, 0xFF, sizeof(m_motionWakePins));

#ifndef NATIVE_BUILD
    m_wdtClearTimer = nullptr;
#endif
}

PowerManager::~PowerManager() {
#ifndef MOCK_MODE
    if (m_wdtClearTimer) {
        esp_timer_stop(m_wdtClearTimer);
        esp_timer_delete(m_wdtClearTimer);
        m_wdtClearTimer = nullptr;
    }
#endif
}

#ifndef MOCK_MODE
void PowerManager::wdtClearCallback(void* arg) {
    // Runs from esp_timer task (priority 22) every 200ms during the post-wake window.
    // Calls disableCore0WDT() to re-remove IDLE from TWDT, counteracting the IDF pm
    // module's re-subscription after light sleep wake (Issue #44).
    // Auto-stops when the 15-second post-wake window expires.
    PowerManager* self = static_cast<PowerManager*>(arg);
    disableCore0WDT();
    if (!self->isPostWakeFlushActive()) {
        esp_timer_stop(self->m_wdtClearTimer);
        // NOTE: cannot call DEBUG_LOG_SYSTEM safely from esp_timer task context
    }
}
#endif

void PowerManager::setBatteryMonitoringEnabled(bool enabled) {
    m_batteryMonitoringEnabled = enabled;
}

void PowerManager::setPowerSavingMode(uint8_t mode) {
    if (mode > 2) mode = 0;
    if (mode == m_powerSavingMode) return;  // No change — avoid redundant writes and log spam

    // Defensive: log the old state before modifying it
    DEBUG_LOG_SYSTEM("Power: setPowerSavingMode(%u) called (current mode=%u, autoSleep=%s, deepSleep=%s)",
        mode, m_powerSavingMode,
        m_config.enableAutoSleep ? "true" : "false",
        m_config.enableDeepSleep ? "true" : "false");

    m_powerSavingMode = mode;
    m_config.enableAutoSleep = (mode >= 1);
    m_config.enableDeepSleep = (mode == 2);
    DEBUG_LOG_SYSTEM("Power: mode set to %u (autoSleep=%s, deepSleep=%s)",
        mode,
        m_config.enableAutoSleep ? "true" : "false",
        m_config.enableDeepSleep ? "true" : "false");
}

void PowerManager::setEnablePowerSavingOnUSB(bool enable) {
    if (m_enablePowerSavingOnUSB != enable) {
        DEBUG_LOG_SYSTEM("USB power override: %s -> %s",
                         m_enablePowerSavingOnUSB ? "ON" : "OFF",
                         enable ? "ON" : "OFF");
        m_enablePowerSavingOnUSB = enable;

        // Immediately re-evaluate power state
        if (!enable && m_batteryStatus.usbPower && m_state != STATE_USB_POWER) {
            // Override disabled + USB connected -> force USB_POWER state
            setState(STATE_USB_POWER, "USB override disabled");
        } else if (enable && m_state == STATE_USB_POWER && m_batteryStatus.usbPower) {
            // Override enabled + in USB_POWER state -> return to ACTIVE
            DEBUG_LOG_SYSTEM("USB override enabled - allowing power saving on USB power");
            setState(STATE_ACTIVE, "USB override enabled");
        }
    }
}

void PowerManager::setMotionWakePins(const uint8_t* pins, uint8_t count) {
    if (count > MAX_MOTION_WAKE_PINS) count = MAX_MOTION_WAKE_PINS;
    m_motionWakePinCount = count;
    memcpy(m_motionWakePins, pins, count);
    DEBUG_LOG_SYSTEM("Power: setMotionWakePins — %u pin(s) registered", count);
}

bool PowerManager::begin(const Config* config) {
    if (m_initialized) {
        DEBUG_LOG_SYSTEM("Power: Already initialized");
        return true;
    }

    // Apply custom configuration if provided
    if (config) {
        m_config = *config;
    }

    DEBUG_LOG_SYSTEM("Power: Initializing");

#ifndef MOCK_MODE
    // Configure ADC for battery voltage reading
    // Note: ESP32-C3 uses different ADC API - analogRead() works via Arduino framework
    // The adc1_config functions are deprecated in newer ESP-IDF
    #if !CONFIG_IDF_TARGET_ESP32C3
    adc1_config_width(ADC_WIDTH_BIT_12);
    adc1_config_channel_atten(BATTERY_ADC_CHANNEL, ADC_ATTEN_DB_12);
    #else
    // ESP32-C3: battery is on ADC2_CH0 (GPIO5), read via adc_ll_* HAL functions
    // which bypass the ADC driver entirely.  Three things the driver normally
    // does must be replicated here:
    //   1. Configure the GPIO as an analog input (no pulls).
    //   2. Enable the SAR ADC peripheral clock (APB source, un-gate it).
    //   3. Set power management to FSM mode so the hardware powers the SAR
    //      on/off automatically for each oneshot conversion.
    // Without (2) and (3) the onetime_start bit is written but the peripheral
    // never clocks, so the conversion never completes and raw reads as garbage.
    // Always initialise the ADC hardware; actual reads are gated at runtime by
    // m_batteryMonitoringEnabled (set via setBatteryMonitoringEnabled()).
    gpio_set_direction((gpio_num_t)PIN_BATTERY_ADC, GPIO_MODE_INPUT);
    gpio_pullup_dis((gpio_num_t)PIN_BATTERY_ADC);
    gpio_pulldown_dis((gpio_num_t)PIN_BATTERY_ADC);
    adc_ll_digi_controller_clk_div(ADC_LL_CLKM_DIV_NUM_DEFAULT,   // Set clock divider
                                   ADC_LL_CLKM_DIV_B_DEFAULT,   // before enabling clock —
                                   ADC_LL_CLKM_DIV_A_DEFAULT);  // div=0 means no output.
    adc_ll_digi_clk_sel(false);                     // APB clock source + sar_clk_gated = 1
    APB_SARADC.apb_adc_clkm_conf.clk_en = 1;       // Actually enable the clock module output.
                                                     // clk_sel + sar_clk_gated alone are not
                                                     // sufficient; this bit (default 0) gates
                                                     // the divided clock into the SAR peripheral.
    adc_ll_digi_set_power_manage(ADC_POWER_BY_FSM); // FSM drives XPD for oneshot polling

    // Calibrate ADC from per-chip eFuse coefficients.  characterize()
    // only reads eFuses — safe alongside adc_ll_* reads.  Falls back
    // to 3 300 mV default Vref if no calibration data is burned.
    {
        esp_adc_cal_value_t calType = esp_adc_cal_characterize(
            ADC_UNIT_2, ADC_ATTEN_DB_12, ADC_WIDTH_BIT_12,
            3300,                   // default Vref fallback (mV)
            &m_adcCalChars);
        m_adcCalValid = true;

        switch (calType) {
            case ESP_ADC_CAL_VAL_EFUSE_TP_FIT: m_adcCalMethod = "TP+Fit";     break;
            case ESP_ADC_CAL_VAL_EFUSE_TP:     m_adcCalMethod = "Two-Point";  break;
            case ESP_ADC_CAL_VAL_EFUSE_VREF:   m_adcCalMethod = "eFuse Vref"; break;
            default:                           m_adcCalMethod = "default";    break;
        }
        DEBUG_LOG_SYSTEM("Power: ADC cal method=%s", m_adcCalMethod);
    }

    // VBUS detection (GPIO6): pull down so it reads LOW when USB is disconnected.
    // Without this the pin floats HIGH on battery-only and isUsbPower() returns true.
    // Always active — USB detection is useful regardless of battery monitoring.
    gpio_set_direction((gpio_num_t)PIN_VBUS_DETECT, GPIO_MODE_INPUT);
    gpio_pulldown_en((gpio_num_t)PIN_VBUS_DETECT);
    #endif

    // Issue #44: Create the post-wake WDT clear timer (one-time setup; started at each wake)
    {
        esp_timer_create_args_t timerArgs = {};
        timerArgs.callback = &PowerManager::wdtClearCallback;
        timerArgs.arg = this;
        timerArgs.dispatch_method = ESP_TIMER_TASK;
        timerArgs.name = "wdt_clear";
        timerArgs.skip_unhandled_events = true;
        esp_timer_create(&timerArgs, &m_wdtClearTimer);
        DEBUG_LOG_SYSTEM("Power: WDT clear timer created (Issue #44)");
    }
#endif

    m_startTime = millis();
    m_lastActivity = millis();
    m_lastBatteryUpdate = 0; // Force immediate update

    // Try to restore state from RTC memory
    if (restoreStateFromRTC()) {
        // Release any GPIO holds that were latched before deep sleep.
        // gpio_hold_en() persists across deep-sleep reboot; without this,
        // any post-wake write to the held pin (e.g. recalibrate toggling
        // PIN_PIR_POWER LOW) is silently ignored.
#ifndef MOCK_MODE
        if (PIN_PIR_POWER != PIN_PIR_POWER_NONE) {
            gpio_hold_dis((gpio_num_t)PIN_PIR_POWER);
            DEBUG_LOG_SYSTEM("Power: gpio_hold released on PIR power pin GPIO%d", PIN_PIR_POWER);
        }
#endif

        // Deep sleep reboots the CPU — wakeCount was already incremented by
        // restoreStateFromRTC(), so go straight to source detection without
        // calling wakeUp() (which would double-increment).
        m_state = STATE_DEEP_SLEEP;   // Correct previous state for wake log
        uint32_t deepSleepDurationMs = 0;
#ifndef MOCK_MODE
        deepSleepDurationMs = (uint32_t)(rtc_time_get() - rtcMemory.sleepEntryRTC) * 1000;
#endif
        m_stats.deepSleepTime = rtcMemory.deepSleepAccumulatedSec + (deepSleepDurationMs / 1000);
        detectAndRouteWakeSource(deepSleepDurationMs);
    } else {
        DEBUG_LOG_SYSTEM("Power: Fresh boot, initializing RTC memory");
        rtcMemory.magic = RTC_MAGIC;
        rtcMemory.wakeCount = 0;
        rtcMemory.deepSleepCount = 0;
    }

    m_initialized = true;

    // Initial battery check
    updateBatteryStatus();

    DEBUG_LOG_SYSTEM("Power: Initialized (battery: %.2fV, %u%%)",
             m_batteryStatus.voltage, m_batteryStatus.percentage);

    // Critical battery boot protection
    // If battery is critical and not charging, show warning and shutdown.
    // Sanity guard: a LiPo powering the MCU can never actually read below
    // ~2.5 V.  Anything below 2.0 V is an ADC read failure — do NOT shut
    // down in that case or the device becomes unrecoverable without a full
    // erase.
    if (m_batteryStatus.voltage < 2.0f) {
        DEBUG_LOG_SYSTEM("Power: WARNING - battery voltage %.2fV is suspiciously low (likely ADC failure). Skipping shutdown protection.", m_batteryStatus.voltage);
    } else if (millis() - m_startTime < POWER_BOOT_GRACE_PERIOD_MS) {
        DEBUG_LOG_SYSTEM("Power: Boot grace period active (%ums) - deferring critical battery check", POWER_BOOT_GRACE_PERIOD_MS);
    } else if (m_batteryStatus.critical && !m_batteryStatus.usbPower) {
        DEBUG_LOG_SYSTEM("Power: Critical battery detected on boot (%.2fV), shutting down", m_batteryStatus.voltage);

        #ifndef MOCK_MODE
        // Flash LED 3 times as shutdown warning
        pinMode(PIN_HAZARD_LED, OUTPUT);
        for (int i = 0; i < 3; i++) {
            // Use raw GPIO to avoid dependency on LED HAL
            digitalWrite(PIN_HAZARD_LED, HIGH);
            delay(200);
            digitalWrite(PIN_HAZARD_LED, LOW);
            delay(200);
        }
        #endif

        // Enter deep sleep immediately (device will not wake until charged)
        enterDeepSleep(0, "critical battery boot");
        // Never returns
    }

    return true;
}

void PowerManager::update() {
    if (!m_initialized) {
        return;
    }

    // Update battery status periodically
    if (millis() - m_lastBatteryUpdate >= m_config.batteryCheckInterval) {
        updateBatteryStatus();
        m_lastBatteryUpdate = millis();
    }

    // Handle power state
    handlePowerState();

    // Update statistics
    updateStats();

    // Log periodic state summary
    logStateSummary();
}

void PowerManager::updateBatteryStatus() {
    // Read voltage
    float voltage = getBatteryVoltage();
    m_batteryStatus.voltage = voltage;

    // Calculate percentage
    m_batteryStatus.percentage = calculateBatteryPercentage(voltage);

    // Check USB power state
    bool wasUsbPower = m_batteryStatus.usbPower;
    m_batteryStatus.usbPower = isUsbPower();

    // Detect USB power connection
    if (m_batteryStatus.usbPower && !wasUsbPower) {
        DEBUG_LOG_SYSTEM("Power: USB power connected");
        if (m_onUsbPower) {
            m_onUsbPower();
        }
    }

    // Check battery thresholds
    bool wasLow = m_batteryStatus.low;
    bool wasCritical = m_batteryStatus.critical;

    m_batteryStatus.low = (voltage < m_config.lowBatteryThreshold);
    m_batteryStatus.critical = (voltage < m_config.criticalBatteryThreshold);

    // Trigger callbacks on state changes
    if (m_batteryStatus.critical && !wasCritical) {
        DEBUG_LOG_SYSTEM("Power: Critical battery! (%.2fV)", voltage);
        if (m_onCriticalBattery) {
            m_onCriticalBattery();
        }
    } else if (m_batteryStatus.low && !wasLow) {
        DEBUG_LOG_SYSTEM("Power: Low battery (%.2fV)", voltage);
        if (m_onLowBattery) {
            m_onLowBattery();
        }
    }

    // Overvoltage warning — fires once per event, resets when voltage
    // drops back.  Guards against charger malfunction or sensor error.
    {
        static bool overvoltageWarned = false;
        if (m_batteryMonitoringEnabled && voltage > 4.3f) {
            if (!overvoltageWarned) {
                DEBUG_LOG_SYSTEM("Power: WARNING overvoltage %.2fV (max expected 4.2V)", voltage);
                overvoltageWarned = true;
            }
        } else {
            overvoltageWarned = false;
        }
    }
}

float PowerManager::getBatteryVoltage() {
    float rawVoltage = readBatteryVoltageRaw();
    addVoltageSample(rawVoltage);
    return getFilteredVoltage();
}

float PowerManager::readBatteryVoltageRaw() {
#ifndef MOCK_MODE
    if (!m_batteryMonitoringEnabled) {
        // Battery monitoring is disabled at runtime.  Return nominal voltage
        // so the system does not trigger low/critical battery state transitions.
        // Enable via the web UI config tab (requires external voltage divider
        // on GPIO5 — see docs/hardware/HARDWARE_ASSEMBLY.md).
        return 3.8f;
    }
    // ESP32-C3: GPIO5 is ADC2_CH0. The ADC driver in libdriver.a is
    // pre-compiled and unconditionally rejects ADC2 on C3 — the
    // CONFIG_ADC_ONESHOT_FORCE_USE_ADC2_ON_C3 build flag cannot reach it.
    // Use adc_ll inline HAL functions to read the SAR ADC registers directly,
    // bypassing the driver validation entirely.
#if CONFIG_IDF_TARGET_ESP32C3
    adc_ll_onetime_set_channel(ADC_NUM_2, ADC_CHANNEL_0);  // ADC2, channel 0 = GPIO5
    adc_ll_onetime_set_atten(ADC_ATTEN_DB_12);     // 12dB attenuation: 0-3.3V
    adc_ll_onetime_sample_enable(ADC_NUM_2, true);
    adc_ll_onetime_start(true);

    // Poll for conversion complete (typically sub-microsecond)
    uint32_t timeout = 1000;
    while (APB_SARADC.onetime_sample.onetime_start && --timeout) {}

    uint16_t raw = adc_ll_adc2_read();
#else
    uint16_t raw = analogRead(PIN_BATTERY_ADC);
#endif

    // Convert raw count → voltage.  Calibrated path uses per-chip eFuse
    // polynomial; fallback is the original linear formula.
    float voltage;
    if (m_adcCalValid) {
        uint32_t adcMv = esp_adc_cal_raw_to_voltage(raw, &m_adcCalChars);
        voltage = (adcMv / 1000.0f) * BATTERY_DIVIDER_RATIO;
    } else {
        voltage = (raw / 4095.0f) * 3.3f * BATTERY_DIVIDER_RATIO;
    }

    // Apply calibration offset
    voltage += m_config.voltageCalibrationOffset;

    // VERBOSE ADC log, throttled: only on significant change or every 100 s
    {
        static float lastLoggedVoltage = -1.0f;
        static uint32_t lastVoltageLogTime = 0;
        uint32_t now = millis();
        if (lastLoggedVoltage < 0.0f ||
            fabsf(voltage - lastLoggedVoltage) >= 0.05f ||
            (now - lastVoltageLogTime) >= 100000) {
            g_debugLogger.log(DebugLogger::LEVEL_VERBOSE, DebugLogger::CAT_SYSTEM,
                "Power: ADC2 raw=%u voltage=%.3fV", raw, voltage);
            lastLoggedVoltage = voltage;
            lastVoltageLogTime = now;
        }
    }

    return voltage;
#else
    // Mock mode: return simulated voltage
    return 3.8f; // Nominal battery voltage
#endif
}

uint8_t PowerManager::getBatteryPercentage() {
    return m_batteryStatus.percentage;
}

uint8_t PowerManager::calculateBatteryPercentage(float voltage) {
    // LiPo discharge curve (simplified piecewise linear)
    // 4.2V = 100%
    // 3.7V = 50%
    // 3.0V = 0%

    // Clamp voltage range
    if (voltage >= 4.2f) return 100;
    if (voltage <= 3.0f) return 0;

    // Piecewise linear approximation
    if (voltage >= 3.7f) {
        // 3.7V-4.2V = 50%-100% (0.5V range = 50% capacity)
        return 50 + (uint8_t)(((voltage - 3.7f) / 0.5f) * 50.0f);
    } else {
        // 3.0V-3.7V = 0%-50% (0.7V range = 50% capacity)
        return (uint8_t)(((voltage - 3.0f) / 0.7f) * 50.0f);
    }
}

void PowerManager::addVoltageSample(float voltage) {
    m_voltageSamples[m_voltageSampleIndex] = voltage;
    m_voltageSampleIndex = (m_voltageSampleIndex + 1) % VOLTAGE_SAMPLES;
    if (m_voltageSampleIndex == 0) {
        m_voltageSamplesFilled = true;
    }
}

float PowerManager::getFilteredVoltage() {
    float sum = 0.0f;
    int count = m_voltageSamplesFilled ? VOLTAGE_SAMPLES : m_voltageSampleIndex;

    if (count == 0) return 0.0f;

    for (int i = 0; i < count; i++) {
        sum += m_voltageSamples[i];
    }

    return sum / count;
}

bool PowerManager::isUsbPower() {
#ifndef MOCK_MODE
    // Check VBUS detection pin
    return digitalRead(VBUS_DETECT_PIN) == HIGH;
#else
    // Mock mode: no USB power
    return false;
#endif
}

void PowerManager::handlePowerState() {
#ifndef MOCK_MODE
#endif

    switch (m_state) {
        case STATE_ACTIVE:
        case STATE_MOTION_ALERT:
            // Boot grace period: suppress battery transitions and auto-sleep
            // until ADC has settled and USB power has been reliably detected.
            // USB power detection is still allowed during the grace period.
            if (millis() - m_startTime < POWER_BOOT_GRACE_PERIOD_MS) {
                // Log grace period status every 10 seconds
                static uint32_t lastGraceLog = 0;
                if (millis() - lastGraceLog >= 10000) {
                    uint32_t remaining = POWER_BOOT_GRACE_PERIOD_MS - (millis() - m_startTime);
                    DEBUG_LOG_SYSTEM_VERBOSE("Boot grace period: %lums remaining - sleep blocked", remaining);
                    lastGraceLog = millis();
                }
                if (m_batteryStatus.usbPower && !m_enablePowerSavingOnUSB) {
                    setState(STATE_USB_POWER);
                }
                break;
            }
            // Check for battery issues
            if (m_batteryStatus.critical && !m_batteryStatus.usbPower) {
                // Cast uint8_t to float to avoid va_list type mismatch
                float criticalPercent = (float)m_batteryStatus.percentage;
                DEBUG_LOG_SYSTEM("Critical battery: %.2fV (%.0f%%) - entering CRITICAL_BATTERY state",
                                 m_batteryStatus.voltage, criticalPercent);
                setState(STATE_CRITICAL_BATTERY);
            } else if (m_batteryStatus.low && !m_batteryStatus.usbPower) {
                // Cast uint8_t to float to avoid va_list type mismatch
                float lowPercent = (float)m_batteryStatus.percentage;
                DEBUG_LOG_SYSTEM("Low battery: %.2fV (%.0f%%) - entering LOW_BATTERY state",
                                 m_batteryStatus.voltage, lowPercent);
                setState(STATE_LOW_BATTERY);
            } else if (m_batteryStatus.usbPower && !m_enablePowerSavingOnUSB) {
                DEBUG_LOG_SYSTEM("USB power detected - transitioning to USB_POWER state (sleep disabled)");
                setState(STATE_USB_POWER);
            } else if (m_config.enableAutoSleep && shouldEnterSleep()) {
                char reason[64];
                snprintf(reason, sizeof(reason), "idle timeout %ums", millis() - m_lastActivity);
#ifndef MOCK_MODE
                // Feed watchdog before initiating sleep sequence
                esp_task_wdt_reset();
                DEBUG_LOG_SYSTEM("Pre-sleep: watchdog fed, about to call sleep function");
#endif
                if (m_config.enableDeepSleep && m_config.lightSleepToDeepSleepMs == 0) {
#ifndef MOCK_MODE
                    esp_task_wdt_reset();
                    DEBUG_LOG_SYSTEM("Pre-sleep: calling enterDeepSleep() - free heap: %d bytes",
                                     esp_get_free_heap_size());
#endif
                    enterDeepSleep(0, reason);
                } else {
                    uint32_t sleepDuration = 0;
                    if (m_config.enableDeepSleep && m_config.lightSleepToDeepSleepMs > 0) {
                        sleepDuration = m_config.lightSleepToDeepSleepMs;
                    }
#ifndef MOCK_MODE
                    esp_task_wdt_reset();
                    // DIAGNOSTIC LOG: Show how sleep duration was computed to catch underflow bugs
                    DEBUG_LOG_SYSTEM("Pre-sleep: calculated sleepDuration=%lu (enableDeepSleep=%d, lightSleepToDeepSleepMs=%lu)",
                                     sleepDuration, m_config.enableDeepSleep, m_config.lightSleepToDeepSleepMs);
                    DEBUG_LOG_SYSTEM("Pre-sleep: calling enterLightSleep(%lu) - free heap: %d bytes",
                                     sleepDuration, esp_get_free_heap_size());
#endif
                    enterLightSleep(sleepDuration, reason);
                }
            }
            break;

        case STATE_LIGHT_SLEEP:
            // Transition to deep sleep is handled inside enterLightSleep()
            // via a timer wakeup — this state is only held during the
            // blocking esp_light_sleep_start() call.
            break;

        case STATE_DEEP_SLEEP:
            // Handled by deep sleep wake-up (system reboots)
            break;

        case STATE_LOW_BATTERY:
            // Check if battery recovered
            if (m_batteryStatus.usbPower) {
                setState(STATE_USB_POWER);
            } else if (!m_batteryStatus.low) {
                setState(STATE_ACTIVE);
            } else if (m_batteryStatus.critical) {
                setState(STATE_CRITICAL_BATTERY);
            }
            break;

        case STATE_CRITICAL_BATTERY:
            // Only exit if USB power connected
            if (m_batteryStatus.usbPower) {
                setState(STATE_USB_POWER);
            } else {
                enterDeepSleep(0, "critical battery"); // Indefinite sleep until charged
            }
            break;

        case STATE_USB_POWER:
            // Log periodic reminder that sleep is disabled on USB
            {
                static uint32_t lastUSBLog = 0;
                if (millis() - lastUSBLog >= 300000) {  // Every 5 minutes
                    DEBUG_LOG_SYSTEM_VERBOSE("USB_POWER state: sleep disabled while on USB power (battery: %.2fV)",
                                     m_batteryStatus.voltage);
                    lastUSBLog = millis();
                }
            }
            // If override was enabled at runtime, return to ACTIVE
            if (m_enablePowerSavingOnUSB) {
                setState(STATE_ACTIVE, "USB override enabled");
            }
            // Return to active when unplugged
            else if (!m_batteryStatus.usbPower) {
                if (m_batteryStatus.critical) {
                    setState(STATE_CRITICAL_BATTERY);
                } else if (m_batteryStatus.low) {
                    setState(STATE_LOW_BATTERY);
                } else {
                    setState(STATE_ACTIVE);
                }
            }
            break;
    }
}

void PowerManager::logStateSummary() {
    static uint32_t lastSummaryLog = 0;

    // Log every 5 minutes
    if (millis() - lastSummaryLog < 300000) {
        return;
    }
    lastSummaryLog = millis();

    uint32_t idleTime = millis() - m_lastActivity;
    uint32_t timeInState = millis() - m_stateEnterTime;

    // Pre-compute all complex expressions to avoid stack corruption in variadic functions
    uint32_t stateMinutes = timeInState / 60000;
    uint32_t stateSeconds = (timeInState % 60000) / 1000;
    const char* batterySource = m_batteryStatus.usbPower ? "[USB]" : "[BAT]";
    const char* autoSleepStr = m_config.enableAutoSleep ? "ON" : "OFF";
    const char* deepSleepStr = m_config.enableDeepSleep ? "ON" : "OFF";
    const char* usbOverrideStr = m_enablePowerSavingOnUSB ? "ON" : "OFF";
    uint32_t idleSeconds = idleTime / 1000;
    uint32_t idleDecimals = (idleTime % 1000) / 100;
    uint32_t thresholdSeconds = m_config.idleToLightSleepMs / 1000;
    uint32_t thresholdDecimals = (m_config.idleToLightSleepMs % 1000) / 100;
    // Cast uint8_t to float to avoid va_list type mismatch
    float summaryPercent = (float)m_batteryStatus.percentage;
    const char* stateName = getStateName(m_state);

    // Build sleep status into buffer (safe for va_list — passed as single %s)
    char sleepStatus[64];
    if (m_state == STATE_USB_POWER) {
        snprintf(sleepStatus, sizeof(sleepStatus), "BLOCKED (USB)");
    } else if (m_state == STATE_CRITICAL_BATTERY || m_state == STATE_LOW_BATTERY) {
        snprintf(sleepStatus, sizeof(sleepStatus), "BLOCKED (battery)");
    } else if (!m_config.enableAutoSleep) {
        snprintf(sleepStatus, sizeof(sleepStatus), "BLOCKED (mode=%d)", m_powerSavingMode);
    } else if (idleTime < m_config.idleToLightSleepMs) {
        uint32_t remaining = m_config.idleToLightSleepMs - idleTime;
        uint32_t remainingSeconds = remaining / 1000;
        uint32_t remainingDecimals = (remaining % 1000) / 100;
        snprintf(sleepStatus, sizeof(sleepStatus), "WAITING (need %lu.%lus more)",
                 (unsigned long)remainingSeconds, (unsigned long)remainingDecimals);
    } else {
        snprintf(sleepStatus, sizeof(sleepStatus), "READY");
    }

    // Compact 2-line summary (all VERBOSE)
    DEBUG_LOG_SYSTEM_VERBOSE("Power summary: %s %lum%lus | %.2fV %.0f%% %s | mode=%d autoSleep=%s deepSleep=%s",
        stateName, (unsigned long)stateMinutes, (unsigned long)stateSeconds,
        m_batteryStatus.voltage, summaryPercent, batterySource,
        m_powerSavingMode, autoSleepStr, deepSleepStr);
    DEBUG_LOG_SYSTEM_VERBOSE("Power summary: idle=%lu.%lus/%lu.%lus usbOverride=%s | sleep=%s",
        (unsigned long)idleSeconds, (unsigned long)idleDecimals,
        (unsigned long)thresholdSeconds, (unsigned long)thresholdDecimals,
        usbOverrideStr, sleepStatus);
}

void PowerManager::setState(PowerState newState, const char* reason) {
    if (m_state != newState) {
        if (reason) {
            DEBUG_LOG_SYSTEM("Power: %s -> %s (%s)",
                getStateName(m_state), getStateName(newState), reason);
        } else {
            DEBUG_LOG_SYSTEM("Power: %s -> %s",
                getStateName(m_state), getStateName(newState));
        }
        m_state = newState;
        m_stateEnterTime = millis();
    }
}

bool PowerManager::shouldEnterSleep() {
    uint32_t idleTime = millis() - m_lastActivity;

    if (!m_config.enableAutoSleep) {
        // Log only every 60 seconds to avoid spam
        static uint32_t lastAutoSleepLog = 0;
        if (millis() - lastAutoSleepLog >= 60000) {
            DEBUG_LOG_SYSTEM_VERBOSE("Sleep check: autoSleep=DISABLED - sleep not allowed");
            lastAutoSleepLog = millis();
        }
        return false;
    }

    if (idleTime >= m_config.idleToLightSleepMs) {
        DEBUG_LOG_SYSTEM_VERBOSE("Sleep check: READY - idle=%lums >= timeout=%lums",
                         idleTime, m_config.idleToLightSleepMs);
        return true;
    }

    // Log only every 60 seconds to avoid spam
    static uint32_t lastIdleLog = 0;
    if (millis() - lastIdleLog >= 60000) {
        uint32_t remaining = m_config.idleToLightSleepMs - idleTime;
        // Pre-compute arithmetic to avoid va_list stack corruption
        uint32_t remainingSeconds = remaining / 1000;
        uint32_t remainingDeciseconds = (remaining % 1000) / 100;
        DEBUG_LOG_SYSTEM("Sleep check: NOT READY - idle=%lums < timeout=%lums (need %lu.%lus more)",
                         idleTime, m_config.idleToLightSleepMs,
                         remainingSeconds, remainingDeciseconds);
        lastIdleLog = millis();
    }

    return false;
}

void PowerManager::enterLightSleep(uint32_t duration_ms, const char* reason) {
    // CRITICAL VALIDATION: Reject zero or dangerously low sleep durations
    // Bug fix for Issue #44 - enterLightSleep(0) caused watchdog timeout
    const uint32_t MIN_SLEEP_MS = 100;
    if (duration_ms > 0 && duration_ms < MIN_SLEEP_MS) {
        DEBUG_LOG_SYSTEM("ERROR: enterLightSleep(%lu) below minimum %ums - rejecting sleep request",
                         duration_ms, MIN_SLEEP_MS);
        m_state = STATE_ACTIVE;
        return;
    }

    DEBUG_LOG_SYSTEM_VERBOSE("Entering light sleep: duration=%lums", duration_ms);
    uint32_t entryStartMs = millis();

    const char* prevStateName = getStateName(m_state);
    m_state = STATE_LIGHT_SLEEP;
    m_stateEnterTime = millis();
    if (reason) {
        DEBUG_LOG_SYSTEM_VERBOSE("Power: %s -> LIGHT_SLEEP (%s)", prevStateName, reason);
    } else {
        DEBUG_LOG_SYSTEM_VERBOSE("Power: %s -> LIGHT_SLEEP", prevStateName);
    }
    saveStateToRTC();
    DEBUG_LOG_SYSTEM("Light sleep: RTC state saved (elapsed: %lums)", millis() - entryStartMs);

    // Statics for wake snapshot — declared outside MOCK_MODE guard so they are
    // in scope for the log line after Serial.begin().  Assigned inside the guard;
    // in MOCK_MODE they stay at 0.
    static uint8_t s_wakeGPIO1   = 0;
    static uint8_t s_wakeGPIO4   = 0;
    static uint8_t s_wakePirPwr  = 0;
    static uint8_t s_wakeMcuSel  = 0;
    static int     s_wakeCause   = 0;   // int avoids esp_sleep_wakeup_cause_t in MOCK_MODE

#ifndef MOCK_MODE
    // Feed watchdog before entering sleep sequence
    DEBUG_LOG_SYSTEM("Light sleep: feeding watchdog before sleep preparation");
    esp_task_wdt_reset();

    // Reduce CPU frequency (ESP32-C3 max is 160MHz, not 240MHz)
    DEBUG_LOG_SYSTEM_VERBOSE("Light sleep: reducing CPU 160MHz -> 80MHz");
    setCPUFrequency(80);
    DEBUG_LOG_SYSTEM("Light sleep: CPU frequency reduced to 80MHz");

    // gpio_config() (not gpio_set_direction) is required here: it reconfigures
    // the IO_MUX function-select back to GPIO mode.  gpio_set_direction only
    // touches the GPIO controller direction bit and leaves IO_MUX unchanged.
    for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
        gpio_num_t pin = (gpio_num_t)m_motionWakePins[i];
        gpio_config_t io_conf = {};
        io_conf.pin_bit_mask = (1ULL << pin);
        io_conf.mode          = GPIO_MODE_INPUT;
        io_conf.intr_type     = GPIO_INTR_DISABLE;

        if (pin == (gpio_num_t)PIN_PIR_NEAR) {
            // GPIO1 pad is XTAL_32K_N on ESP32-C3.  The clock-gate
            // transition inside esp_light_sleep_start() produces a
            // momentary HIGH glitch on this pad every time, regardless
            // of IO_MUX, pull, or UART0 state.  Arming it as a HIGH-level
            // wakeup source causes an immediate spurious wake on every
            // sleep entry.  Confirmed via bisection (Issue #38).
            // Mitigation: leave as bare INPUT (no pull) during sleep so
            // the glitch cannot latch the wakeup controller.  Pull-up is
            // restored after wake (see gpio_wakeup_disable block).
            // Near-PIR motion is still readable in ACTIVE/MOTION_ALERT;
            // only the sleep wake-up path is affected.
            io_conf.pull_up_en    = GPIO_PULLUP_DISABLE;
            io_conf.pull_down_en  = GPIO_PULLDOWN_DISABLE;
            gpio_config(&io_conf);
            // intentionally not armed as a wakeup source
        } else {
            io_conf.pull_up_en    = GPIO_PULLUP_ENABLE;
            gpio_config(&io_conf);
            esp_err_t wakeErr = gpio_wakeup_enable(pin, GPIO_INTR_HIGH_LEVEL);
            DEBUG_LOG_SYSTEM_VERBOSE("Light sleep: GPIO%d armed HIGH-level wakeup (rc=%d)", (int)pin, (int)wakeErr);
        }
    }

    {
        gpio_config_t btn_conf = {};
        btn_conf.pin_bit_mask = (1ULL << BUTTON_PIN);
        btn_conf.mode          = GPIO_MODE_INPUT;
        btn_conf.pull_up_en    = GPIO_PULLUP_ENABLE;
        btn_conf.intr_type     = GPIO_INTR_DISABLE;
        gpio_config(&btn_conf);
        esp_err_t btnWakeErr = gpio_wakeup_enable((gpio_num_t)BUTTON_PIN, GPIO_INTR_LOW_LEVEL);
        DEBUG_LOG_SYSTEM_VERBOSE("Light sleep: GPIO%d armed LOW-level wakeup (rc=%d)", BUTTON_PIN, (int)btnWakeErr);
    }

    // Log which wake sources are armed
    DEBUG_LOG_SYSTEM("=== LIGHT SLEEP WAKE SOURCES ===");
    for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
        gpio_num_t pin = (gpio_num_t)m_motionWakePins[i];
        if (pin == (gpio_num_t)PIN_PIR_NEAR) {
            DEBUG_LOG_SYSTEM("GPIO%d (near PIR): configured but NOT armed (Issue #38 workaround)", pin);
        } else {
            DEBUG_LOG_SYSTEM("GPIO%d (far PIR): ARMED for HIGH-level wake", pin);
        }
    }
    DEBUG_LOG_SYSTEM("GPIO0 (button): ARMED for LOW-level wake (boot button)");
    DEBUG_LOG_SYSTEM("================================");

    DEBUG_LOG_SYSTEM("Light sleep: GPIO wakeup sources configured");
    esp_task_wdt_reset();

    // Timer wakeup for light→deep transition.  Subtract the setup
    // overhead (millis() - m_stateEnterTime) so the timer covers only
    // the remaining duration from the caller's perspective.
    if (duration_ms > 0) {
        uint32_t elapsedMs = millis() - m_stateEnterTime;
        if (duration_ms > elapsedMs) {
            uint32_t remainingMs = duration_ms - elapsedMs;

            // Bounds checking: ESP32 light sleep timer can overflow with very large values.
            // Cap at 1 hour per sleep cycle to prevent timer overflow issues.
            if (remainingMs > 3600000) {  // Max 1 hour per light sleep cycle
                remainingMs = 3600000;
                DEBUG_LOG_SYSTEM("Light sleep: duration capped at 1h to prevent timer overflow");
            }

            // Validate timer value won't overflow uint64_t microseconds
            uint64_t timerUs = (uint64_t)remainingMs * 1000ULL;
            if (timerUs > (UINT64_MAX / 2)) {
                DEBUG_LOG_SYSTEM("ERROR: Timer overflow risk detected (timer=%lluus), aborting sleep",
                                 timerUs);
                // Return without entering sleep - device stays active
                m_state = STATE_ACTIVE;
                return;
            }

            esp_sleep_enable_timer_wakeup(timerUs);
            DEBUG_LOG_SYSTEM_VERBOSE("Light sleep: timer wakeup enabled (%lums remaining)", remainingMs);
        }
    }
    DEBUG_LOG_SYSTEM("Light sleep: timer wakeup configured");

    // Combined pre-sleep diagnostic: IO_MUX MCU_SEL, GPIO4 wakeup register, live pin levels
    {
        uint32_t iomuxVal = REG_READ(IO_MUX_GPIO1_REG);
        uint8_t mcuSel = (iomuxVal >> MCU_SEL_S) & MCU_SEL_V;
        uint32_t pin4Val = REG_READ(GPIO_PIN4_REG);
        uint8_t pin4IntType = GPIO_PIN_INT_TYPE_GET(pin4Val);
        uint8_t pin4WakeupEn = GPIO_PIN_WAKEUP_ENABLE_GET(pin4Val);

        char diagLog[128];
        int pos = snprintf(diagLog, sizeof(diagLog),
            "Sleep diag: MCU_SEL=%d GPIO4[int=%d wake=%d]",
            mcuSel, pin4IntType, pin4WakeupEn);
        for (uint8_t i = 0; i < m_motionWakePinCount && pos < 110; i++) {
            int lvl = gpio_get_level((gpio_num_t)m_motionWakePins[i]);
            pos += snprintf(diagLog + pos, sizeof(diagLog) - pos,
                           " GPIO%d=%d", m_motionWakePins[i], lvl);
        }
        {
            int btnLvl = gpio_get_level((gpio_num_t)BUTTON_PIN);
            pos += snprintf(diagLog + pos, sizeof(diagLog) - pos, " Btn=%d", btnLvl);
        }
        {
            int pirPwrLvl = gpio_get_level((gpio_num_t)PIN_PIR_POWER);
            snprintf(diagLog + pos, sizeof(diagLog) - pos, " PIR_PWR=%d", pirPwrLvl);
        }
        DEBUG_LOG_SYSTEM_VERBOSE("%s", diagLog);
    }

    // Hold GPIO20 (PIR sensor power rail) OUTPUT HIGH during light sleep.
    // ESP32-C3 does not automatically retain GPIO output values through the
    // light-sleep clock-gate transition — without gpio_hold_en the output
    // reverts to 0, cutting power to both AM312 sensors.  gpio_hold_dis()
    // is called after wake before any sensor reads.
    gpio_hold_en((gpio_num_t)PIN_PIR_POWER);

    // Global GPIO wakeup enable — must come AFTER all gpio_wakeup_enable()
    // calls per ESP-IDF documented order (esp_sleep.h §287).
    esp_sleep_enable_gpio_wakeup();
    DEBUG_LOG_SYSTEM("Light sleep: global GPIO wakeup enabled");

    // Feed watchdog before Serial shutdown (this can take time)
    esp_task_wdt_reset();
    DEBUG_LOG_SYSTEM("Light sleep: flushing Serial buffer");
    Serial.flush();  // Drain buffer while peripheral is still open

    DEBUG_LOG_SYSTEM("Light sleep: shutting down Serial (calling Serial.end())");
    Serial.end();    // Cleanly shut down USB-JTAG-Serial.  end() + begin()
                     // on wake forces a cold-start the host can recover from.

    // Log battery voltage before sleep
    float batteryV = m_batteryStatus.voltage;
    uint8_t batteryPct = m_batteryStatus.percentage;
    DEBUG_LOG_SYSTEM("Pre-sleep battery: %.2fV (%u%%)", batteryV, batteryPct);

    // Issue #44: Stop WDT clear timer before sleep (will be restarted at wake)
    if (m_wdtClearTimer && esp_timer_is_active(m_wdtClearTimer)) {
        esp_timer_stop(m_wdtClearTimer);
        DEBUG_LOG_SYSTEM("Light sleep: WDT clear timer stopped");
    }

    // CRITICAL FIX (Issue #44): Remove loopTask from watchdog before sleep.
    // esp_light_sleep_start() can take >5s, which would trigger a false-positive TASK_WDT.
    // IDLE task is permanently excluded from the watchdog at startup via disableCore0WDT() in main.cpp.
    esp_task_wdt_delete(NULL);  // loopTask (current task)
    DEBUG_LOG_SYSTEM("Light sleep: Removed loopTask from watchdog for sleep entry");

    // Disconnect WiFi before sleep. Closes TCP connections gracefully so
    // ESPAsyncWebServer (async_tcp, priority 3) has nothing heavy to clean up at wake.
    // Do NOT call WiFi.mode(WIFI_OFF) here — doing so forces an 8-second RF recalibration
    // when WiFi.mode(WIFI_STA) is called at wake, which monopolizes the CPU at priority 23
    // and starves IDLE from the TWDT — the exact crash seen in Issue #44 crash #13.
    DEBUG_LOG_SYSTEM("Pre-sleep: WiFi disconnect");
    g_debugLogger.flush();
    WiFi.disconnect(false);  // false = keep AP credentials; radio stays in STA mode
    DEBUG_LOG_SYSTEM("Pre-sleep: WiFi disconnected (radio stays on)");
    g_debugLogger.flush();

    // NOTE: No Serial logging possible after this point until Serial.begin() on wake
    esp_light_sleep_start();

    // Capture pin state at the exact moment of wake.  Serial is not yet
    // available — store into statics declared above; log after Serial.begin().
    s_wakeGPIO1  = gpio_get_level((gpio_num_t)PIN_PIR_NEAR);
    s_wakeGPIO4  = gpio_get_level((gpio_num_t)PIN_PIR_FAR);
    s_wakePirPwr = gpio_get_level((gpio_num_t)PIN_PIR_POWER);
    s_wakeCause  = (int)esp_sleep_get_wakeup_cause();
    s_wakeMcuSel = (REG_READ(IO_MUX_GPIO1_REG) >> MCU_SEL_S) & MCU_SEL_V;
#endif

    // Wake.  Re-initialise USB-JTAG-Serial.  Must remain outside
    // #ifndef MOCK_MODE so native test builds also exercise this path.
    Serial.begin(SERIAL_BAUD_RATE);

#ifndef MOCK_MODE
    // === Issue #44 DIAGNOSTIC: Force-flush after every log during wake ===
    // We are completely blind during the 8s crash window after wake.
    // Each step gets logged + flushed so data survives a crash.

    // Step 1: Serial re-initialized
    DEBUG_LOG_SYSTEM("Wake step 1/9: Serial re-initialized");
    g_debugLogger.flush();

    // Step 2: Re-subscribe loopTask to watchdog, remove IDLE
    esp_task_wdt_add(NULL);  // loopTask
    disableCore0WDT();       // Re-remove IDLE (Issue #44)
    DEBUG_LOG_SYSTEM("Wake step 2/9: WDT reconfigured (loopTask added, IDLE removed)");
    g_debugLogger.flush();

    // Step 3: Log wake event
    {
        esp_sleep_wakeup_cause_t cause = esp_sleep_get_wakeup_cause();
        const char* causeStr = "Other";
        if (cause == ESP_SLEEP_WAKEUP_EXT0) causeStr = "EXT0 (button)";
        else if (cause == ESP_SLEEP_WAKEUP_TIMER) causeStr = "Timer";
        else if (cause == ESP_SLEEP_WAKEUP_GPIO) causeStr = "GPIO (PIR/button)";
        DEBUG_LOG_SYSTEM("Wake step 3/9: Wake cause=%d (%s)", (int)cause, causeStr);
        g_debugLogger.flush();
    }
#endif

    // Calculate total time from entry to wake (includes sleep duration)
    uint32_t totalWakeTime = millis() - entryStartMs;
    DEBUG_LOG_SYSTEM("Wake step 4/9: Total sleep time %lums, heap=%lu",
        totalWakeTime, (unsigned long)ESP.getFreeHeap());
    g_debugLogger.flush();

    DEBUG_LOG_SYSTEM_VERBOSE("Wake snapshot: cause=%d GPIO1=%d GPIO4=%d PIR_PWR=%d MCU_SEL=%d",
                     s_wakeCause, s_wakeGPIO1, s_wakeGPIO4,
                     s_wakePirPwr, s_wakeMcuSel);

#ifndef MOCK_MODE
    // Step 5: Restore CPU frequency (prime suspect for IDLE re-subscription via APB callbacks)
    DEBUG_LOG_SYSTEM("Wake step 5/9: About to restore CPU to 160MHz");
    g_debugLogger.flush();
    setCPUFrequency(160);
    DEBUG_LOG_SYSTEM("Wake step 5/9: CPU restored to 160MHz — DONE");
    g_debugLogger.flush();

    // Step 6: Disable stale GPIO wakeup sources
    for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
        gpio_wakeup_disable((gpio_num_t)m_motionWakePins[i]);
    }
    gpio_wakeup_disable((gpio_num_t)BUTTON_PIN);
    DEBUG_LOG_SYSTEM("Wake step 6/9: GPIO wakeup sources disabled");
    g_debugLogger.flush();

    // Step 7: Release PIR power hold
    gpio_hold_dis((gpio_num_t)PIN_PIR_POWER);
    DEBUG_LOG_SYSTEM("Wake step 7/9: PIR power hold released");
    g_debugLogger.flush();

    // Step 8: Restore GPIO1 (near PIR) pull-up
    {
        gpio_config_t restore_conf = {};
        restore_conf.pin_bit_mask = (1ULL << PIN_PIR_NEAR);
        restore_conf.mode          = GPIO_MODE_INPUT;
        restore_conf.pull_up_en    = GPIO_PULLUP_ENABLE;
        restore_conf.intr_type     = GPIO_INTR_DISABLE;
        gpio_config(&restore_conf);
    }
    DEBUG_LOG_SYSTEM("Wake step 8/9: GPIO1 pullup restored");
    g_debugLogger.flush();

    // Deep sleep transition check
    {
        esp_sleep_wakeup_cause_t cause = esp_sleep_get_wakeup_cause();
        if (cause == ESP_SLEEP_WAKEUP_TIMER && m_config.enableDeepSleep) {
            DEBUG_LOG_SYSTEM_VERBOSE("Light sleep: timer expired, entering deep sleep");
            enterDeepSleep(0, "light sleep timeout");
            // Never reaches here
        }
    }
#endif

    // millis() on ESP32 is compensated for light sleep time
    uint32_t sleepDuration = millis() - m_stateEnterTime;

    // Credit sleep-time counters now, while m_state is still LIGHT_SLEEP.
    uint32_t sleepSec = sleepDuration / 1000;
    m_stats.lightSleepTime += sleepSec;
    m_stats.sleepTime      += sleepSec;
    m_lastStatsUpdate       = millis();

    wakeUp(sleepDuration);

    // Step 9: Wake sequence complete — back in loop() soon
    DEBUG_LOG_SYSTEM("Wake step 9/9: wakeUp() complete, state=%s, returning to loop()",
        getStateName(m_state));
    g_debugLogger.flush();

    // Enable post-wake forced flush mode for 15 seconds.
    // Any DebugLogger write during this window will auto-flush to disk.
    m_postWakeFlushUntil = millis() + 15000;

#ifndef MOCK_MODE
    // Issue #44: Start periodic WDT clear timer for the 15-second post-wake window.
    // Fires every 200ms from esp_timer task (priority 22), calling disableCore0WDT()
    // even while WiFi task (priority 23) monopolizes the CPU during reconnect.
    // This prevents IDLE from accumulating 8s on the TWDT watchlist after wake.
    if (m_wdtClearTimer) {
        if (esp_timer_is_active(m_wdtClearTimer)) {
            esp_timer_stop(m_wdtClearTimer);
        }
        esp_timer_start_periodic(m_wdtClearTimer, 200 * 1000); // 200ms in microseconds
        DEBUG_LOG_SYSTEM("Wake: WDT clear timer started (200ms period, 15s window, Issue #44)");
        g_debugLogger.flush();
    }
#endif

}

void PowerManager::enterDeepSleep(uint32_t duration_ms, const char* reason) {
    setState(STATE_DEEP_SLEEP, reason);
    saveStateToRTC();

#ifndef MOCK_MODE
    // Configure wake sources
    if (duration_ms > 0) {
        esp_sleep_enable_timer_wakeup(duration_ms * 1000ULL);
    }

    // Button: always uses standard deep sleep GPIO wakeup (wakes on LOW — button pressed)
    gpio_set_direction((gpio_num_t)BUTTON_PIN, GPIO_MODE_INPUT);
    gpio_pullup_en((gpio_num_t)BUTTON_PIN);
    esp_deep_sleep_enable_gpio_wakeup(1ULL << BUTTON_PIN, ESP_GPIO_WAKEUP_GPIO_LOW);

    // PIR: mode 2 uses ULP coprocessor instead of GPIO wakeup for detection.
    // Modes 0/1 should not normally reach enterDeepSleep(), but configure GPIO
    // wakeup as a safety fallback if they do.  All registered motion pins
    // share HIGH polarity so they can be combined into a single bitmask call.
    if (m_powerSavingMode != 2) {
        uint64_t pirMask = 0;
        for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
            gpio_set_direction((gpio_num_t)m_motionWakePins[i], GPIO_MODE_INPUT);
            pirMask |= (1ULL << m_motionWakePins[i]);
        }
        if (pirMask) {
            esp_deep_sleep_enable_gpio_wakeup(pirMask, ESP_GPIO_WAKEUP_GPIO_HIGH);
        }
    }

    // Hold PIR power GPIO HIGH so sensors stay powered during deep sleep.
    // GPIO outputs tri-state without hold; if PIR loses VCC it cannot wake us.
    if (PIN_PIR_POWER != PIN_PIR_POWER_NONE) {
        digitalWrite(PIN_PIR_POWER, HIGH);
        gpio_hold_en((gpio_num_t)PIN_PIR_POWER);
    }

    // Mode 2: load and start ULP RISC-V program to monitor PIR GPIO
    if (m_powerSavingMode == 2) {
        startULPPirMonitor();
    }

    // Enter deep sleep (no return - system reboots on wake)
    esp_deep_sleep_start();
#endif
}

void PowerManager::wakeUp(uint32_t sleepDurationMs) {
    m_stats.wakeCount++;
    m_lastActivity = millis();

    detectAndRouteWakeSource(sleepDurationMs);

    if (m_onWake) {
        m_onWake();
    }
}

void PowerManager::detectAndRouteWakeSource(uint32_t sleepDurationMs) {
    const char* prevStateName = getStateName(m_state);
    const char* wakeSource = "Unknown";
    PowerState newState = STATE_ACTIVE;

    #ifndef MOCK_MODE
    esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();

    switch (wakeup_reason) {
        case ESP_SLEEP_WAKEUP_GPIO:
            // ESP32-C3 reports a single GPIO wake cause regardless of which pin
            // triggered it.  Read button first; if not pressed, scan motion pins.
            // Only route to MOTION_ALERT if a motion pin is actually HIGH now —
            // a momentary glitch that has already cleared must not trigger an alert.
            if (gpio_get_level((gpio_num_t)BUTTON_PIN) == 0) {
                wakeSource = "Button";
                newState = STATE_ACTIVE;
            } else {
                bool motionHigh = false;
                for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
                    if (gpio_get_level((gpio_num_t)m_motionWakePins[i]) == 1) {
                        motionHigh = true;
                        break;
                    }
                }
                if (motionHigh) {
                    wakeSource = "PIR motion";
                    newState = STATE_MOTION_ALERT;
                } else {
                    wakeSource = "Spurious GPIO wake (no pin HIGH)";
                    newState = STATE_ACTIVE;
                }
            }
            break;

        case ESP_SLEEP_WAKEUP_TIMER:
            wakeSource = "Timer";
            newState = STATE_ACTIVE;
            break;

        case ESP_SLEEP_WAKEUP_UNDEFINED:
            // If RTC indicates we were in light sleep, a crash/watchdog
            // reset occurred rather than a clean boot.  Scan motion-wake
            // pins: if any is HIGH the motion event that triggered the
            // original wake is still active — route to MOTION_ALERT so
            // the alert injection in main.cpp setup can fire.
            if (rtcMemory.lastState == STATE_LIGHT_SLEEP) {
                bool motionActive = false;
                for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
                    if (gpio_get_level((gpio_num_t)m_motionWakePins[i]) == 1) {
                        motionActive = true;
                        break;
                    }
                }
                if (motionActive) {
                    wakeSource = "PIR motion (crash recovery)";
                    newState = STATE_MOTION_ALERT;
                } else {
                    wakeSource = "Light sleep crash (no motion)";
                    newState = STATE_ACTIVE;
                }
            } else {
                wakeSource = "Normal boot";
                newState = STATE_ACTIVE;
            }
            break;

        case ESP_SLEEP_WAKEUP_ULP:
            // ULP woke us — this is always PIR motion (ULP only runs in
            // mode 2 and only triggers on GPIO1 HIGH).
            wakeSource = "ULP PIR motion";
            newState = STATE_MOTION_ALERT;
            break;

        default:
            wakeSource = "Unknown";
            newState = STATE_ACTIVE;
            break;
    }
    #endif

    // Format sleep duration
    char durationBuf[32];
    if (sleepDurationMs >= 60000) {
        // Pre-compute arithmetic to avoid va_list stack corruption
        uint32_t durationMinutes = sleepDurationMs / 60000;
        uint32_t durationSeconds = (sleepDurationMs % 60000) / 1000;
        snprintf(durationBuf, sizeof(durationBuf), "%um %us",
            durationMinutes, durationSeconds);
    } else if (sleepDurationMs >= 1000) {
        // Pre-compute arithmetic to avoid va_list stack corruption
        uint32_t durationSeconds = sleepDurationMs / 1000;
        snprintf(durationBuf, sizeof(durationBuf), "%us", durationSeconds);
    } else {
        snprintf(durationBuf, sizeof(durationBuf), "%ums", sleepDurationMs);
    }

    // Single combined wake log — set state directly to avoid a second log from setState
    m_state = newState;
    m_stateEnterTime = millis();
    DEBUG_LOG_SYSTEM("Power: %s -> %s (wake: %s, slept %s)",
        prevStateName, getStateName(newState), wakeSource, durationBuf);
}

void PowerManager::recordActivity(const char* source) {
    m_lastActivity = millis();
    if (source) {
        g_debugLogger.log(DebugLogger::LEVEL_VERBOSE, DebugLogger::CAT_SYSTEM,
                         "Activity recorded: %s (idle timer reset)", source);
    } else {
        g_debugLogger.log(DebugLogger::LEVEL_VERBOSE, DebugLogger::CAT_SYSTEM,
                         "Activity recorded (idle timer reset)");
    }
}

uint32_t PowerManager::getTimeSinceActivity() const {
    return millis() - m_lastActivity;
}

void PowerManager::setCPUFrequency(uint8_t mhz) {
#ifndef MOCK_MODE
    // ESP32-C3 max frequency is 160MHz (not 240MHz like original ESP32)
    #if CONFIG_IDF_TARGET_ESP32C3
    if (mhz > 160) {
        mhz = 160;
    }
    #endif

    setCpuFrequencyMhz(mhz);
    DEBUG_LOG_SYSTEM_VERBOSE("Power: CPU frequency set to %uMHz", mhz);
#endif
}

void PowerManager::setLEDBrightness(uint8_t percentage) {
    // This will be called by LED HAL implementations
    // Just log for now
    DEBUG_LOG_SYSTEM("Power: LED brightness set to %u%%", percentage);
}

void PowerManager::saveStateToRTC() {
    rtcMemory.magic = RTC_MAGIC;
    rtcMemory.lastState = m_state;
    rtcMemory.lastBatteryVoltage = m_batteryStatus.voltage;
    rtcMemory.deepSleepCount++;
#ifndef MOCK_MODE
    rtcMemory.sleepEntryRTC = (time_t)rtc_time_get();
#else
    rtcMemory.sleepEntryRTC = 0;
#endif
    rtcMemory.deepSleepAccumulatedSec = m_stats.deepSleepTime;
}

bool PowerManager::restoreStateFromRTC() {
    if (rtcMemory.magic != RTC_MAGIC) {
        return false;
    }

    m_stats.wakeCount = rtcMemory.wakeCount + 1;
    m_stats.deepSleepCount = rtcMemory.deepSleepCount;
    rtcMemory.wakeCount = m_stats.wakeCount;

    return true;
}

void PowerManager::updateStats() {
    m_stats.uptime = (millis() - m_startTime) / 1000;

    // Accumulate time in current state since last stats tick
    uint32_t timeInState = (millis() - m_lastStatsUpdate) / 1000;

    if (m_state == STATE_ACTIVE || m_state == STATE_USB_POWER) {
        m_stats.activeTime += timeInState;
    } else {
        m_stats.sleepTime += timeInState;
        if (m_state == STATE_LIGHT_SLEEP) {
            m_stats.lightSleepTime += timeInState;
        }
    }

    m_lastStatsUpdate = millis();

    // Calculate average current (simplified)
    // This would need actual current measurement in real implementation
    switch (m_state) {
        case STATE_ACTIVE:
            m_stats.avgCurrent = 240.0f; // mA
            break;
        case STATE_LIGHT_SLEEP:
            m_stats.avgCurrent = 30.0f;
            break;
        case STATE_DEEP_SLEEP:
            m_stats.avgCurrent = 0.12f;
            break;
        case STATE_LOW_BATTERY:
            m_stats.avgCurrent = 150.0f; // Reduced features
            break;
        case STATE_USB_POWER:
            m_stats.avgCurrent = 240.0f; // Full features on USB power
            break;
        default:
            m_stats.avgCurrent = 0.0f;
            break;
    }
}

void PowerManager::resetStats() {
    m_stats.uptime = 0;
    m_stats.activeTime = 0;
    m_stats.sleepTime = 0;
    m_stats.lightSleepTime = 0;
    m_stats.deepSleepTime = 0;
    m_stats.wakeCount = 0;
    m_stats.deepSleepCount = 0;
    m_stats.avgCurrent = 0.0f;

    m_startTime = millis();
    m_lastStatsUpdate = millis();
    DEBUG_LOG_SYSTEM("Power: Statistics reset");
}

void PowerManager::startULPPirMonitor() {
#ifndef MOCK_MODE
#ifdef HAS_ULP_RISCV
    // Configure GPIO1 (PIR) as a clean input for ULP access
    gpio_set_direction((gpio_num_t)PIR_SENSOR_PIN, GPIO_MODE_INPUT);
    gpio_pullup_dis((gpio_num_t)PIR_SENSOR_PIN);
    gpio_pulldown_dis((gpio_num_t)PIR_SENSOR_PIN);

    // Load ULP binary into RTC SLOW memory.
    // esp_ulp_load_program len parameter is in WORDS; the size linker symbol is in BYTES.
    esp_err_t err = esp_ulp_load_program(0, ulp_pir_monitor_start,
                                         ulp_pir_monitor_size / sizeof(uint32_t));
    if (err != ESP_OK) {
        DEBUG_LOG_SYSTEM("Power: ULP load failed: %s. Falling back to GPIO wakeup.",
                         esp_err_to_string(err));
        {
            uint64_t pirMask = 0;
            for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
                pirMask |= (1ULL << m_motionWakePins[i]);
            }
            if (pirMask) {
                esp_deep_sleep_enable_gpio_wakeup(pirMask, ESP_GPIO_WAKEUP_GPIO_HIGH);
            }
        }
        return;
    }

    err = esp_ulp_start(0);
    if (err != ESP_OK) {
        DEBUG_LOG_SYSTEM("Power: ULP start failed: %s. Falling back to GPIO wakeup.",
                         esp_err_to_string(err));
        {
            uint64_t pirMask = 0;
            for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
                pirMask |= (1ULL << m_motionWakePins[i]);
            }
            if (pirMask) {
                esp_deep_sleep_enable_gpio_wakeup(pirMask, ESP_GPIO_WAKEUP_GPIO_HIGH);
            }
        }
        return;
    }

    DEBUG_LOG_SYSTEM("Power: ULP PIR monitor started");
#else
    // ULP RISC-V not available in this build environment (framework-arduinoespressif32
    // does not bundle ulp headers/lib for ESP32-C3 yet).  Fall back to standard GPIO
    // deep-sleep wakeup.  Motion detection still works; wakeup cause will be GPIO
    // rather than ESP_SLEEP_WAKEUP_ULP.
    DEBUG_LOG_SYSTEM("Power: ULP not available (build env). Using GPIO wakeup for PIR.");
    {
        uint64_t pirMask = 0;
        for (uint8_t i = 0; i < m_motionWakePinCount; i++) {
            gpio_set_direction((gpio_num_t)m_motionWakePins[i], GPIO_MODE_INPUT);
            pirMask |= (1ULL << m_motionWakePins[i]);
        }
        if (pirMask) {
            esp_deep_sleep_enable_gpio_wakeup(pirMask, ESP_GPIO_WAKEUP_GPIO_HIGH);
        }
    }
#endif
#endif
}

const char* PowerManager::getStateName(PowerState state) {
    switch (state) {
        case STATE_ACTIVE: return "ACTIVE";
        case STATE_MOTION_ALERT: return "MOTION_ALERT";
        case STATE_LIGHT_SLEEP: return "LIGHT_SLEEP";
        case STATE_DEEP_SLEEP: return "DEEP_SLEEP";
        case STATE_LOW_BATTERY: return "LOW_BATTERY";
        case STATE_CRITICAL_BATTERY: return "CRITICAL_BATTERY";
        case STATE_USB_POWER: return "USB_POWER";
        default: return "UNKNOWN";
    }
}
