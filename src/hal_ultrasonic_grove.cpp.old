#include "hal_ultrasonic_grove.h"
#include <Arduino.h>

// Static capabilities definition
const SensorCapabilities HAL_Ultrasonic_Grove::s_capabilities = getDefaultCapabilities(SENSOR_TYPE_ULTRASONIC_GROVE);

HAL_Ultrasonic_Grove::HAL_Ultrasonic_Grove(uint8_t sigPin, bool mock_mode)
    : m_sigPin(sigPin),
      m_mockMode(mock_mode),
      m_initialized(false),
      m_currentDistance(0),
      m_lastDistance(0),
      m_detectionThreshold(DEFAULT_THRESHOLD_MM),
      m_minDistance(s_capabilities.minDetectionDistance),
      m_maxDistance(s_capabilities.maxDetectionDistance),
      m_objectDetected(false),
      m_directionEnabled(false),
      m_direction(DIRECTION_UNKNOWN),
      m_directionSensitivity(DEFAULT_SENSITIVITY_MM),
      m_directionTriggerMode(0),  // Default: approaching only
      m_rapidSampleCount(5),
      m_rapidSampleMs(100),
      m_sampleWindowIndex(0),
      m_sampleWindowCount(0),
      m_windowAverage(0),
      m_lastWindowAverage(0),
      m_windowFilled(false),
      m_lastEvent(MOTION_EVENT_NONE),
      m_eventCount(0),
      m_lastEventTime(0),
      m_lastMeasurementTime(0),
      m_measurementInterval(MIN_MEASUREMENT_INTERVAL_MS),
      m_mockDistance(0)
{
    // Initialize sample window to zeros
    for (uint8_t i = 0; i < SAMPLE_WINDOW_SIZE; i++) {
        m_sampleWindow[i] = 0;
    }
}

HAL_Ultrasonic_Grove::~HAL_Ultrasonic_Grove()
{
}

bool HAL_Ultrasonic_Grove::begin()
{
    if (m_mockMode) {
        // Mock mode: no hardware initialization
        m_initialized = true;
        return true;
    }

    // Configure pin (will switch between OUTPUT and INPUT during measurement)
    pinMode(m_sigPin, OUTPUT);
    digitalWrite(m_sigPin, LOW);

    m_initialized = true;
    return true;
}

void HAL_Ultrasonic_Grove::update()
{
    if (!m_initialized) {
        return;
    }

    // Check if enough time has passed since last measurement
    uint32_t now = millis();
    if (now - m_lastMeasurementTime < m_measurementInterval) {
        return;
    }

    // Perform measurement
    uint32_t rawDistance = measureDistance();

    // Only process valid readings
    if (rawDistance > 0) {
        // Add to rolling window
        addSampleToWindow(rawDistance);

        // Store previous averages for direction detection
        m_lastWindowAverage = m_windowAverage;
        m_lastDistance = m_currentDistance;

        // Calculate new average from window
        m_windowAverage = calculateWindowAverage();
        m_currentDistance = m_windowAverage;

        // Update direction if enabled
        if (m_directionEnabled && m_windowFilled) {
            updateDirection();
        }

        // Check for threshold crossing events (only if movement detected)
        checkThresholdEvents();
    }

    m_lastMeasurementTime = now;
}

bool HAL_Ultrasonic_Grove::motionDetected() const
{
    return m_objectDetected;
}

bool HAL_Ultrasonic_Grove::isReady() const
{
    return m_initialized;
}

const SensorCapabilities& HAL_Ultrasonic_Grove::getCapabilities() const
{
    return s_capabilities;
}

void HAL_Ultrasonic_Grove::resetEventCount()
{
    m_eventCount = 0;
}

void HAL_Ultrasonic_Grove::setDetectionThreshold(uint32_t threshold_mm)
{
    m_detectionThreshold = threshold_mm;
}

void HAL_Ultrasonic_Grove::setDirectionDetection(bool enable)
{
    m_directionEnabled = enable;
    if (!enable) {
        m_direction = DIRECTION_UNKNOWN;
    }
}

void HAL_Ultrasonic_Grove::mockSetMotion(bool detected)
{
    if (!m_mockMode) {
        return;
    }

    m_objectDetected = detected;
}

void HAL_Ultrasonic_Grove::mockSetDistance(uint32_t distance_mm)
{
    if (!m_mockMode) {
        return;
    }

    m_mockDistance = distance_mm;
    m_currentDistance = distance_mm;

    // Update motion detection based on mock distance
    bool wasDetected = m_objectDetected;
    m_objectDetected = (distance_mm > 0 && distance_mm <= m_detectionThreshold &&
                        distance_mm >= m_minDistance && distance_mm <= m_maxDistance);

    // Generate events
    if (m_objectDetected && !wasDetected) {
        m_lastEvent = MOTION_EVENT_DETECTED;
        m_eventCount++;
        m_lastEventTime = millis();
    } else if (!m_objectDetected && wasDetected) {
        m_lastEvent = MOTION_EVENT_CLEARED;
        m_eventCount++;
        m_lastEventTime = millis();
    }
}

uint32_t HAL_Ultrasonic_Grove::measureDistance()
{
    if (m_mockMode) {
        return m_mockDistance;
    }

    // Grove Ultrasonic Ranger protocol:
    // 1. Send 10µs trigger pulse on SIG pin
    // 2. Switch SIG pin to INPUT
    // 3. Wait for echo HIGH pulse
    // 4. Measure pulse width

    // Step 1: Send trigger pulse (SIG as OUTPUT)
    pinMode(m_sigPin, OUTPUT);
    digitalWrite(m_sigPin, LOW);
    delayMicroseconds(2);
    digitalWrite(m_sigPin, HIGH);
    delayMicroseconds(10);  // 10µs trigger pulse
    digitalWrite(m_sigPin, LOW);

    // Step 2: Switch to INPUT for echo
    pinMode(m_sigPin, INPUT);

    // Step 3 & 4: Wait for echo and measure pulse width
    unsigned long duration = pulseIn(m_sigPin, HIGH, MEASUREMENT_TIMEOUT_US);

    // Check for timeout
    if (duration == 0) {
        return 0;  // Out of range or error
    }

    // Calculate distance in mm
    // Formula: distance = (duration / 2) / 2.91 (for mm)
    // Simplified: distance = duration / 5.82
    uint32_t distance_mm = (uint32_t)((float)duration / 5.82f);

    // Validate range
    if (distance_mm < s_capabilities.minDetectionDistance ||
        distance_mm > s_capabilities.maxDetectionDistance) {
        return 0;  // Out of valid range
    }

    return distance_mm;
}

void HAL_Ultrasonic_Grove::setMeasurementInterval(uint32_t interval_ms)
{
    if (interval_ms < MIN_MEASUREMENT_INTERVAL_MS) {
        interval_ms = MIN_MEASUREMENT_INTERVAL_MS;
    }
    m_measurementInterval = interval_ms;
}

void HAL_Ultrasonic_Grove::setDirectionSensitivity(uint32_t sensitivity_mm)
{
    m_directionSensitivity = sensitivity_mm;
}

void HAL_Ultrasonic_Grove::setDistanceRange(uint32_t min_mm, uint32_t max_mm)
{
    m_minDistance = min_mm;
    m_maxDistance = max_mm;
}

void HAL_Ultrasonic_Grove::setRapidSampling(uint8_t sample_count, uint16_t interval_ms)
{
    if (sample_count < 2) sample_count = 2;
    if (sample_count > 20) sample_count = 20;

    m_rapidSampleCount = sample_count;
    m_rapidSampleMs = interval_ms;
}

void HAL_Ultrasonic_Grove::triggerRapidSample()
{
    if (!m_initialized) {
        return;
    }

    uint32_t samples[20];  // Max 20 samples
    uint8_t count = m_rapidSampleCount < 20 ? m_rapidSampleCount : 20;

    // Take rapid samples
    for (uint8_t i = 0; i < count; i++) {
        samples[i] = measureDistance();
        if (i < count - 1) {
            delay(m_rapidSampleMs);
        }
    }

    // Update direction based on samples
    updateDirectionFromSamples(samples, count);

    // Update current distance to last sample
    m_currentDistance = samples[count - 1];
}

void HAL_Ultrasonic_Grove::updateDirection()
{
    // Direction detection based on window average change (not single samples)
    int32_t change = (int32_t)m_windowAverage - (int32_t)m_lastWindowAverage;

    if (abs(change) < (int32_t)m_directionSensitivity) {
        m_direction = DIRECTION_STATIONARY;
    } else if (change < 0) {
        // Distance decreasing = approaching
        m_direction = DIRECTION_APPROACHING;
        DEBUG_PRINTF("[HAL_Ultrasonic_Grove] Direction: APPROACHING (change: %ld mm)\n", change);
    } else {
        // Distance increasing = receding
        m_direction = DIRECTION_RECEDING;
        DEBUG_PRINTF("[HAL_Ultrasonic_Grove] Direction: RECEDING (change: %ld mm)\n", change);
    }
}

void HAL_Ultrasonic_Grove::updateDirectionFromSamples(const uint32_t* samples, uint8_t count)
{
    if (count < 2) {
        return;
    }

    // Calculate trend: are distances generally decreasing or increasing?
    int32_t totalChange = 0;
    for (uint8_t i = 1; i < count; i++) {
        totalChange += (int32_t)samples[i] - (int32_t)samples[i - 1];
    }

    int32_t avgChange = totalChange / (count - 1);

    if (abs(avgChange) < (int32_t)m_directionSensitivity) {
        m_direction = DIRECTION_STATIONARY;
    } else if (avgChange < 0) {
        // Distance decreasing = approaching
        m_direction = DIRECTION_APPROACHING;
        m_lastEvent = MOTION_EVENT_APPROACHING;
        m_lastEventTime = millis();
    } else {
        // Distance increasing = receding
        m_direction = DIRECTION_RECEDING;
        m_lastEvent = MOTION_EVENT_RECEDING;
        m_lastEventTime = millis();
    }
}

// =========================================================================
// Rolling Window for Movement Detection
// =========================================================================

void HAL_Ultrasonic_Grove::addSampleToWindow(uint32_t distance_mm) {
    // Add sample to circular buffer
    m_sampleWindow[m_sampleWindowIndex] = distance_mm;

    // Advance index (circular)
    m_sampleWindowIndex = (m_sampleWindowIndex + 1) % SAMPLE_WINDOW_SIZE;

    // Track number of valid samples
    if (m_sampleWindowCount < SAMPLE_WINDOW_SIZE) {
        m_sampleWindowCount++;
    }

    // Mark window as filled once we have enough samples
    if (m_sampleWindowCount >= SAMPLE_WINDOW_SIZE) {
        m_windowFilled = true;
    }
}

uint32_t HAL_Ultrasonic_Grove::calculateWindowAverage() const {
    if (m_sampleWindowCount == 0) {
        return 0;
    }

    uint32_t sum = 0;
    for (uint8_t i = 0; i < m_sampleWindowCount; i++) {
        sum += m_sampleWindow[i];
    }

    return sum / m_sampleWindowCount;
}

bool HAL_Ultrasonic_Grove::isMovementDetected() const {
    // Need filled window to detect movement
    if (!m_windowFilled || m_lastWindowAverage == 0) {
        return false;
    }

    // Calculate change between current and previous window averages
    int32_t change = abs((int32_t)m_windowAverage - (int32_t)m_lastWindowAverage);

    // Also check the range within current window to filter out noise
    // Find min/max in current window
    uint32_t minDist = m_sampleWindow[0];
    uint32_t maxDist = m_sampleWindow[0];
    for (uint8_t i = 1; i < SAMPLE_WINDOW_SIZE; i++) {
        if (m_sampleWindow[i] < minDist) minDist = m_sampleWindow[i];
        if (m_sampleWindow[i] > maxDist) maxDist = m_sampleWindow[i];
    }

    // Range within window (spread of readings)
    uint32_t windowRange = maxDist - minDist;

    // Movement detected if:
    // 1. Average changed significantly (>200mm)
    // 2. AND window shows consistent change (low spread within window OR large overall change)
    bool significantChange = (change >= MOVEMENT_THRESHOLD_MM);
    bool consistentReading = (windowRange < 100);  // Readings are stable (not noisy)

    // Detect movement if we see significant change with consistent readings
    // OR if the change is very large (>300mm) regardless of consistency
    return (significantChange && consistentReading) || (change >= 300);
}

void HAL_Ultrasonic_Grove::checkThresholdEvents()
{
    // Check if object crossed threshold
    bool wasDetected = m_objectDetected;

    // Check if object is in range
    bool inRange = (m_currentDistance > 0 &&
                   m_currentDistance >= m_minDistance &&
                   m_currentDistance <= m_maxDistance);

    // Check for movement
    bool movementDetected = isMovementDetected();

    // If direction detection disabled, just check range
    if (!m_directionEnabled) {
        m_objectDetected = inRange;
    } else {
        // Direction detection enabled - check movement AND direction

        // Check if direction matches configured trigger mode
        bool directionMatches = false;
        switch (m_directionTriggerMode) {
            case 0:  // Approaching only
                directionMatches = (m_direction == DIRECTION_APPROACHING);
                break;
            case 1:  // Receding only
                directionMatches = (m_direction == DIRECTION_RECEDING);
                break;
            case 2:  // Both directions
                directionMatches = (m_direction == DIRECTION_APPROACHING ||
                                   m_direction == DIRECTION_RECEDING);
                break;
            default:
                directionMatches = true;  // Unknown mode, accept any
                break;
        }

        // Object detected if: in range AND moving AND direction matches
        m_objectDetected = inRange && movementDetected && directionMatches;

        DEBUG_PRINTF("[HAL_Ultrasonic_Grove] Check: inRange=%d, movement=%d, dirMatch=%d, dir=%d, trigMode=%d\n",
                     inRange, movementDetected, directionMatches, (int)m_direction, m_directionTriggerMode);
    }

    if (m_objectDetected && !wasDetected) {
        // Object entered threshold with movement
        m_lastEvent = MOTION_EVENT_THRESHOLD_CROSSED;
        m_eventCount++;
        m_lastEventTime = millis();
        DEBUG_PRINTF("[HAL_Ultrasonic_Grove] Motion detected at %u mm (movement: %d mm, event #%u)\n",
                     m_currentDistance, abs((int32_t)m_currentDistance - (int32_t)m_lastWindowAverage), m_eventCount);
    } else if (!m_objectDetected && wasDetected) {
        // Object left threshold or stopped moving
        m_lastEvent = MOTION_EVENT_CLEARED;
        m_eventCount++;
        m_lastEventTime = millis();
        DEBUG_PRINTLN("[HAL_Ultrasonic_Grove] Motion cleared (object left or stopped moving)");
    }
}
